

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>arctern.geoseries.geoseries &mdash; Arctern version : 0.2.0 文档</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script src="../../../_static/translations.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../../../genindex.html" />
    <link rel="search" title="搜索" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> Arctern
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../quick_start/quick_start.html">快速开始</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../feature_description/feature_description.html">功能说明</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_reference/api_reference.html">API 参考</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Arctern</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">模块代码</a> &raquo;</li>
        
      <li>arctern.geoseries.geoseries</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>arctern.geoseries.geoseries 源代码</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (C) 2019-2020 Zilliz. All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="c1"># pylint: disable=useless-super-delegation</span>
<span class="c1"># pylint: disable=too-many-lines</span>
<span class="c1"># pylint: disable=too-many-public-methods</span>
<span class="c1"># pylint: disable=too-many-ancestors, protected-access</span>

<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">Series</span><span class="p">,</span> <span class="n">DataFrame</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">arctern</span>
<span class="kn">from</span> <span class="nn">.geoarray</span> <span class="kn">import</span> <span class="n">GeoArray</span><span class="p">,</span> <span class="n">is_geometry_array</span><span class="p">,</span> <span class="n">GeoDtype</span>


<span class="k">def</span> <span class="nf">fix_dataframe_box_col_volues</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">_box_col_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">items</span><span class="p">):</span>
        <span class="n">klass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">GeoDtype</span><span class="p">):</span>
            <span class="n">klass</span> <span class="o">=</span> <span class="n">GeoSeries</span>

        <span class="k">return</span> <span class="n">klass</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">items</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">DataFrame</span><span class="o">.</span><span class="n">_box_col_values</span> <span class="o">=</span> <span class="n">_box_col_values</span>


<span class="n">fix_dataframe_box_col_volues</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_property_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">this</span><span class="p">):</span>
    <span class="c1"># type: (function, GeoSeries) -&gt; Series[bool/float/object]</span>
    <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">this</span><span class="p">)),</span> <span class="n">index</span><span class="o">=</span><span class="n">this</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_property_geo</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">this</span><span class="p">):</span>
    <span class="c1"># type: (function, GeoSeries) -&gt; GeoSeries</span>
    <span class="k">return</span> <span class="n">GeoSeries</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">this</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">this</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">this</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_unary_geo</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># type: (function, GeoSeries, args, kwargs) -&gt; GeoSeries</span>
    <span class="n">crs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;crs&quot;</span><span class="p">,</span> <span class="n">this</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">GeoSeries</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">this</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">this</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_delegate_binary_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="c1"># type: (function, GeoSeries, GeoSeries/bytes) -&gt; GeoSeries/Series</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">GeoSeries</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">this</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The indices of the two GeoSeries are different.&quot;</span><span class="p">)</span>
            <span class="n">this</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">this</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">this</span><span class="o">.</span><span class="n">index</span>


<span class="k">def</span> <span class="nf">_binary_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="c1"># type: (function, GeoSeries, GeoSeries/bytes) -&gt; Series[bool/float]</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">_delegate_binary_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_binary_geo</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="c1"># type: (function, GeoSeries, GeoSeries/bytes) -&gt; GeoSeries</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">_delegate_binary_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">GeoSeries</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">this</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_validate_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">crs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">crs</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`crs` should be spatial reference identifier string&quot;</span><span class="p">)</span>
    <span class="n">crs</span> <span class="o">=</span> <span class="n">crs</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">if</span> <span class="n">crs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">crs</span>
    <span class="k">return</span> <span class="n">crs</span>


<div class="viewcode-block" id="GeoSeries"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.html#arctern.GeoSeries">[文档]</a><span class="k">class</span> <span class="nc">GeoSeries</span><span class="p">(</span><span class="n">Series</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    One-dimensional Series to store an array of geometry objects.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array-like, Iterable, dict, or scalar value(str or bytes)</span>
<span class="sd">        Contains geometric data stored in GeoSeries. The geometric data can be in `WKT &lt;https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry&gt;`_ or `WKB &lt;https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry#Well-known_binary&gt;`_ format.</span>
<span class="sd">    index : array-like or Index (1d)</span>
<span class="sd">        Same to the index of pandas.Series, by default ``RangeIndex (0, 1, 2, …, n)``.</span>
<span class="sd">        Index values must be hashable and have the same length as ``data``. Non-unique index values are allowed. If both a dict and index sequence are used, the index will override the keys found in the dict.</span>
<span class="sd">    name : str, optional</span>
<span class="sd">        The name to give to the GeoSeries.</span>
<span class="sd">    crs : str, optional</span>
<span class="sd">        The Coordinate Reference System (CRS) set to all geometries in GeoSeries.</span>
<span class="sd">        Only supports SRID as a WKT representation of CRS by now, for example, &quot;EPSG:4326&quot;.</span>
<span class="sd">    **kwargs :</span>
<span class="sd">        Parameters to pass to the GeoSeries constructor, for example, ``copy``.</span>
<span class="sd">        ``copy`` is a boolean value, by default False.</span>

<span class="sd">        * *True:* Copys input data.</span>
<span class="sd">        * *False:* Points to input data.</span>

<span class="sd">    Examples</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">    &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POINT(1 2)&quot;])</span>
<span class="sd">    &gt;&gt;&gt; s</span>
<span class="sd">    0    POINT (1 1)</span>
<span class="sd">    1    POINT (1 2)</span>
<span class="sd">    dtype: GeoDtype</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_sindex</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_sindex_generated</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_metadata</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;crs&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">crs</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">crs</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">crs</span> <span class="o">==</span> <span class="n">crs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;csr of the passed geometry data is different from crs.&quot;</span>
                <span class="p">)</span>
        <span class="c1"># scalar wkb or wkt</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">bytes</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_geometry_array</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">index</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">name</span>

            <span class="kn">from</span> <span class="nn">pandas.api.types</span> <span class="kn">import</span> <span class="n">is_float_dtype</span>
            <span class="c1"># The default dtype for empty Series is &#39;float64&#39; in pandas</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_geometry_array</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">is_float_dtype</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
                <span class="c1"># make sure missing value is None</span>
                <span class="n">s</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">isna</span><span class="p">()]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="kn">from</span> <span class="nn">pandas.api.types</span> <span class="kn">import</span> <span class="n">infer_dtype</span>
                <span class="n">inferred</span> <span class="o">=</span> <span class="n">infer_dtype</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">inferred</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;bytes&quot;</span><span class="p">,</span> <span class="s2">&quot;empty&quot;</span><span class="p">):</span>
                    <span class="k">pass</span>
                <span class="k">elif</span> <span class="n">inferred</span> <span class="o">==</span> <span class="s2">&quot;string&quot;</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">arctern</span><span class="o">.</span><span class="n">ST_GeomFromText</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can not use no bytes or string data to construct GeoSeries.&quot;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">GeoArray</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_crs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sindex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sindex_generated</span><span class="p">:</span>
            <span class="n">_sindex</span> <span class="o">=</span> <span class="n">arctern</span><span class="o">.</span><span class="n">get_sindex_tree</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">_sindex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_sindex</span><span class="o">.</span><span class="n">Append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sindex</span> <span class="o">=</span> <span class="n">_sindex</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sindex_generated</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sindex</span>

<div class="viewcode-block" id="GeoSeries.set_crs"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.set_crs.html#arctern.GeoSeries.set_crs">[文档]</a>    <span class="k">def</span> <span class="nf">set_crs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the Coordinate Reference System (CRS) for all geometries in GeoSeries.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        crs : str</span>
<span class="sd">            A string representation of CRS.</span>
<span class="sd">            The string is made up of an authority code and a SRID (Spatial Reference Identifier), for example, &quot;EPSG:4326&quot;.</span>

<span class="sd">        Notes</span>
<span class="sd">        -------</span>
<span class="sd">        Arctern supports common CRSs listed at the `Spatial Reference &lt;https://spatialreference.org/&gt;`_ website.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POINT(1 2)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.set_crs(&quot;EPSG:4326&quot;)</span>
<span class="sd">        &gt;&gt;&gt; s.crs</span>
<span class="sd">        &#39;EPSG:4326&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">crs</span> <span class="o">=</span> <span class="n">_validate_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_crs</span> <span class="o">=</span> <span class="n">crs</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">crs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Coordinate Reference System (CRS) of the GeoSeries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            CRS of the GeoSeries.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POINT(1 2)&quot;], crs=&quot;EPSG:4326&quot;)</span>
<span class="sd">        &gt;&gt;&gt; s.crs</span>
<span class="sd">        &#39;EPSG:4326&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_crs</span>

    <span class="nd">@crs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">crs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the Coordinate Reference System (CRS) for all geometries in GeoSeries.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        crs : str</span>
<span class="sd">            A string representation of CRS.</span>
<span class="sd">            The string is made up of an authority code and a SRID (Spatial Reference Identifier), for example, &quot;EPSG:4326&quot;.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POINT(1 2)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.set_crs(&quot;EPSG:4326&quot;)</span>
<span class="sd">        &gt;&gt;&gt; s.crs</span>
<span class="sd">        &#39;EPSG:4326&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Some operations result is not geometry type, we should return Series as constructor</span>
        <span class="c1"># e.g.(isna, notna)</span>
        <span class="k">def</span> <span class="nf">_try_constructor</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">GeoDtype</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span>
                <span class="k">return</span> <span class="n">GeoSeries</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_try_constructor</span>

    <span class="c1"># --------------------------------------------------------------------------</span>
    <span class="c1"># override Series method</span>
    <span class="c1"># --------------------------------------------------------------------------</span>

<div class="viewcode-block" id="GeoSeries.equals"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.equals.html#arctern.GeoSeries.equals">[文档]</a>    <span class="k">def</span> <span class="nf">equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tests whether two objects contain the same elements.</span>

<span class="sd">        This function allows two GeoSeries to be compared against each other to see if they have the same shape and elements. NaNs in the same location are considered equal. The column headers do not need to have the same type, but the elements within the columns must be the same dtype.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : GeoSeries</span>
<span class="sd">            The other GeoSeries to be compared with the first GeoSeries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            * *True:* All geometries are the same in both objects.</span>
<span class="sd">            * *False:* The two objects are different in shape or elements.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POINT(1 1)&quot;, None])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;Point(1 1)&quot;, None])</span>
<span class="sd">        &gt;&gt;&gt; s2.equals(s1)</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s3 = GeoSeries([&quot;POLYGON ((1 1,1 2,2 2,2 1))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s4 = GeoSeries([&quot;POLYGON ((1 1,1 2,2 2,2 1))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s4.equals(s3)</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s5 = GeoSeries([&quot;POLYGON ((0 0,2 0,2 2,0 2,0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s6 = GeoSeries([&quot;POLYGON ((0 0,0 2,2 2,2 0,0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s6.equals(s5)</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">GeoSeries</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.fillna"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.fillna.html#arctern.GeoSeries.fillna">[文档]</a>    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">downcast</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fills NA values with a geometry in WKT or WKB format.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value :</span>
<span class="sd">            Value to use to fill holes. This value should be the representation of a geometry in WKT or WKB format. For exmaple, &quot;POINT (1 1)&quot;.</span>
<span class="sd">        method : {&#39;backfill&#39;, &#39;bfill&#39;, &#39;pad&#39;, &#39;ffill&#39;, None}</span>
<span class="sd">            Method to use for filling holes in reindexed Series, by default None.</span>

<span class="sd">            * *pad/ffill:* Propagates the last valid observation forward to fill gap.</span>
<span class="sd">            * *backfill/bfill:* Propagates the next valid observation backward to fill gap.</span>
<span class="sd">        axis : {0 or &#39;index&#39;}</span>
<span class="sd">            Axis along which to fill missing values.</span>
<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Whether to fill NA values in-place, by default False.</span>

<span class="sd">            * *True:* Fills NA values in-place. This will modify any other views on this object.</span>
<span class="sd">            * *False:* Create a new GeoSeries object, and then fill NA values in it.</span>
<span class="sd">        limit : int, optional</span>
<span class="sd">            Limited number of NA values to be filled, by default None. It must be greater than 0 if not None.</span>

<span class="sd">            * If ``method`` is specified, this is the maximum number of consecutive NA values to forward/backward fill. In other words, if there is a gap with more than this number of consecutive NAs, it will only be partially filled.</span>
<span class="sd">            * If ``method`` is not specified, this is the maximum number of entries along the entire axis where NaNs will be filled.</span>
<span class="sd">        downcast : dict, optional</span>
<span class="sd">            A dict of item-&gt;dtype of what to downcast if possible, or the string &#39;infer&#39; which will try to downcast to an appropriate equal type (for example, float64 to int64 if possible). By default None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries or None</span>
<span class="sd">            * None if ``inplace=False``.</span>
<span class="sd">            * A GeoSeries with missing values filled if ``inplace=True``.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;Point (1 1)&quot;, &quot;POLYGON ((1 1,2 1,2 2,1 2,1 1))&quot;, None, &quot;&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0                        POINT (1 1)</span>
<span class="sd">        1    POLYGON ((1 1,2 1,2 2,1 2,1 1))</span>
<span class="sd">        2                               None</span>
<span class="sd">        3                               None</span>
<span class="sd">        dtype: GeoDtype</span>

<span class="sd">        Replace all NA elements with a string in WKT format.</span>

<span class="sd">        &gt;&gt;&gt; s.fillna(&quot;POINT (1 2)&quot;)</span>
<span class="sd">        0                        POINT (1 1)</span>
<span class="sd">        1    POLYGON ((1 1,2 1,2 2,1 2,1 1))</span>
<span class="sd">        2                        POINT (1 2)</span>
<span class="sd">        3                        POINT (1 2)</span>
<span class="sd">        dtype: GeoDtype</span>

<span class="sd">        We can also replace all NA elements with an object in WKB format. Here we use ``s[1]`` as an example of WKB objects because ``s`` is a GeoSeries and all elements stored in GeoSeries are transformed to WKB format.</span>

<span class="sd">        &gt;&gt;&gt; s.fillna(s[1])</span>
<span class="sd">        0                        POINT (1 1)</span>
<span class="sd">        1    POLYGON ((1 1,2 1,2 2,1 2,1 1))</span>
<span class="sd">        2    POLYGON ((1 1,2 1,2 2,1 2,1 1))</span>
<span class="sd">        3    POLYGON ((1 1,2 1,2 2,1 2,1 1))</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">downcast</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.isna"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.isna.html#arctern.GeoSeries.isna">[文档]</a>    <span class="k">def</span> <span class="nf">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detects missing values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Mask of boolean values for each element in the GeoSeries that indicates whether an element is an NA value.</span>

<span class="sd">            * *True*: An element is a NA value, such as None.</span>
<span class="sd">            * *False*: An element is a non-missing value.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;Point (1 1)&quot;, &quot;POLYGON ((1 1,2 1,2 2,1 2,1 1))&quot;, None, &quot;&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.isna()</span>
<span class="sd">        0    False</span>
<span class="sd">        1    False</span>
<span class="sd">        2     True</span>
<span class="sd">        3     True</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span></div>

<div class="viewcode-block" id="GeoSeries.notna"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.notna.html#arctern.GeoSeries.notna">[文档]</a>    <span class="k">def</span> <span class="nf">notna</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detects existing (non-missing) values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Mask of boolean values for each element in the GeoSeries that indicates whether an element is not an NA value.</span>

<span class="sd">            * *True*: An element is a non-missing value.</span>
<span class="sd">            * *False*: An element is a NA value, such as None.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;Point (1 1)&quot;, &quot;POLYGON ((1 1,2 1,2 2,1 2,1 1))&quot;, None, &quot;&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.notna()</span>
<span class="sd">        0     True</span>
<span class="sd">        1     True</span>
<span class="sd">        2    False</span>
<span class="sd">        3    False</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span></div>

    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># Geometry related property</span>
    <span class="c1"># -------------------------------------------------------------------------</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tests whether each geometry in the GeoSeries is in valid format, such as WKT and WKB formats.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Mask of boolean values for each element in the GeoSeries that indicates whether an element is valid.</span>

<span class="sd">            * *True:* The geometry is valid.</span>
<span class="sd">            * *False:* The geometry is invalid.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POINT(1)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.is_valid</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_property_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_IsValid</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the length of each geometry in the GeoSeries.</span>

<span class="sd">        The ways to calculate the length of geometries are as follows:</span>

<span class="sd">        * POINT / MULTIPOINT / POLYGON / MULTIPOLYGON / CURVEPOLYGON / MULTICURVE: 0</span>
<span class="sd">        * LINESTRING: Length of a single straight line.</span>
<span class="sd">        * MULTILINESTRING: Sum of length of multiple straight lines.</span>
<span class="sd">        * CIRCULARSTRING: Length of a single curvilinear line.</span>
<span class="sd">        * MULTISURFACE / COMPOUNDCURVE / GEOMETRYCOLLECTION: For a geometry collection among the 3 types, calculates the sum of length of all geometries in the collection.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Length of each geometry in the GeoSeries.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;LINESTRING (0 0, 0 2)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.length</span>
<span class="sd">        0    0.0</span>
<span class="sd">        1    2.0</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_property_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Length</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_simple</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tests whether each geometry in the GeoSeries is simple.</span>

<span class="sd">        Here &quot;simple&quot; means that a geometry has no anomalous point, such as a self-intersection or a self-tangency.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Mask of boolean values for each element in the GeoSeries that indicates whether an element is simple.</span>

<span class="sd">            * *True:* The geometry is simple.</span>
<span class="sd">            * *False:* The geometry is not simple.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POINT EMPTY&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.is_simple</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_property_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_IsSimple</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the 2D Cartesian (planar) area of each geometry in the GeoSeries.</span>

<span class="sd">        The ways to calculate the area of geometries are as follows:</span>

<span class="sd">        * POINT / MULTIPOINT / LINESTRING / MULTILINESTRING / CIRCULARSTRING: 0</span>
<span class="sd">        * POLYGON: Area of a single polygon.</span>
<span class="sd">        * MULTIPOLYGON: Sum of area of multiple polygons.</span>
<span class="sd">        * CURVEPOLYGON: Area of a single curvilinear polygon.</span>
<span class="sd">        * MULTICURVE: Sum of area of multiple curvilinear polygons.</span>
<span class="sd">        * MULTISURFACE / COMPOUNDCURVE / GEOMETRYCOLLECTION: For a geometry collection among the 3 types, calculates the sum of area of all geometries in the collection.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            2D Cartesian (planar) area of each geometry in the GeoSeries.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POLYGON ((1 1, 3 1, 3 3, 1 3, 1 1))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.area</span>
<span class="sd">        0    0.0</span>
<span class="sd">        1    4.0</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_property_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Area</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">geom_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the type of each geometry in the GeoSeries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            The string representations of geometry types. For example, &quot;ST_LINESTRING&quot;, &quot;ST_POLYGON&quot;, &quot;ST_POINT&quot;, and &quot;ST_MULTIPOINT&quot;.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POLYGON ((1 1, 3 1, 3 3, 1 3, 1 1))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.geom_type</span>
<span class="sd">        0      ST_POINT</span>
<span class="sd">        1    ST_POLYGON</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_property_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_GeometryType</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the centroid of each geometry in the GeoSeries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            The centroid of each geometry in the GeoSeries.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POLYGON ((1 1, 3 1, 3 3, 1 3, 1 1))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.centroid</span>
<span class="sd">        0    POINT (1 1)</span>
<span class="sd">        1    POINT (2 2)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_property_geo</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Centroid</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the closure of the combinatorial boundary of each geometry in the GeoSeries.</span>

<span class="sd">        * For a polygon, the returned geometry is the same as the original.</span>
<span class="sd">        * For a geometry collection, the returned geometry is the combinatorial boundary of all geometries in the collection.</span>
<span class="sd">        * For a point or line, the returned geometry is an empty geometry collection.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            The boundary (low-dimension) of each geometry in the GeoSeries.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POLYGON ((1 1, 3 1, 3 3, 1 3, 1 1))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.boundary</span>
<span class="sd">        0            GEOMETRYCOLLECTION EMPTY</span>
<span class="sd">        1    LINESTRING (1 1,3 1,3 3,1 3,1 1)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_property_geo</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Boundary</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">convex_hull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry in the GeoSeries, returns the smallest convex geometry that encloses it.</span>

<span class="sd">        * For a polygon, the returned geometry is the smallest convex geometry that encloses it.</span>
<span class="sd">        * For a geometry collection, the returned geometry is the smallest convex geometry that encloses all geometries in the collection.</span>
<span class="sd">        * For a point or line, the returned geometry is the same as the original.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Sequence of convex geometries.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        For geometry collections, such as MULTIPOLYGON, MULTISURFACE, and GEOMETRYCOLLECTION, ``convex_hull`` ignores point and line elements and creates the smallest convex geometry that encloses all polygon elements.</span>

<span class="sd">        First, create a MULTIPOLYGON object that contains a concave polygon and a rectangle.</span>

<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; from arctern.plot import plot_geometry</span>
<span class="sd">        &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">        &gt;&gt;&gt; g0 = GeoSeries([&quot;MULTIPOLYGON(((0 0,0 2,1 1,2 2,2 0,0 0)),((2 0,2 2,3 2,3 0,2 0)))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; plot_geometry(ax,g0)</span>

<span class="sd">        Then, use ``convex_hull`` to get the smallest convex geometry that encloses all geometries in the MULTIPOLYGON object.</span>

<span class="sd">        &gt;&gt;&gt; g1 = g0.convex_hull</span>
<span class="sd">        &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">        &gt;&gt;&gt; plot_geometry(ax,g1)</span>

<span class="sd">        Let&#39;s see how ``convex_hull`` deals with a GEOMETRYCOLLECTION that contains a semicircle and a rectangle.</span>

<span class="sd">        &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">        &gt;&gt;&gt; ax.axis(&#39;equal&#39;) # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; g4=GeoSeries([&quot;GEOMETRYCOLLECTION(CURVEPOLYGON(CIRCULARSTRING(1 0,0 1,1 2,1 1,1 0)),polygon((1 0,1 2,2 2,2 0,1 0)))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; plot_geometry(ax,g4.curve_to_line())</span>

<span class="sd">        Use ``convex_hull`` to get the smallest convex geometry that encloses all geometries in the GEOMETRYCOLLECTION object. Since semicircle and rectangle are convex, the returned convex geometry is just a combination of the two gemetries and looks the same as the original.</span>

<span class="sd">        &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">        &gt;&gt;&gt; ax.axis(&#39;equal&#39;) # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; print(g4.convex_hull.to_wkt()[0])</span>
<span class="sd">        CURVEPOLYGON (COMPOUNDCURVE (CIRCULARSTRING (1 0,0 1,1 2),(1 2,2 2,2 0,1 0)))</span>
<span class="sd">        &gt;&gt;&gt; plot_geometry(ax,g4.convex_hull.curve_to_line())</span>

<span class="sd">        ``convex_hull`` will not make any changes to POINT, MULTIPOINT, LINESTRING, MULTILINESTRING, and CIRCULARSTRING.</span>

<span class="sd">        The GeoSeries ``s1`` below contains a point, a line, and a convex polygon.</span>

<span class="sd">        &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">        &gt;&gt;&gt; ax.axis(&#39;equal&#39;) # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(2 0.5)&quot;, &quot;LINESTRING(0 0,3 0.5)&quot;,  &quot;POLYGON ((1 1,3 1,3 3,1 3, 1 1))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; plot_geometry(ax,s)</span>

<span class="sd">        The returned geometries from ``convex_hull`` looks exactly the same as the original.</span>

<span class="sd">        &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">        &gt;&gt;&gt; ax.axis(&#39;equal&#39;) # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; print(s.convex_hull)</span>
<span class="sd">        0                    POINT (2.0 0.5)</span>
<span class="sd">        1           LINESTRING (0 0,3.0 0.5)</span>
<span class="sd">        2    POLYGON ((1 1,1 3,3 3,3 1,1 1))</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &gt;&gt;&gt; plot_geometry(ax,s.convex_hull)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_property_geo</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_ConvexHull</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">npoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of points for each geometry in the GeoSeries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Number of points of each geometry in the GeoSeries.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POLYGON ((1 1, 3 1, 3 3, 1 3, 1 1))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.npoints</span>
<span class="sd">        0    1</span>
<span class="sd">        1    5</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_property_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_NPoints</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">envelope</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the minimum bounding box for each geometry in the GeoSeries.</span>

<span class="sd">        The bounding box is a rectangular geometry object, and its edges are parallel to the axes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Minimum bounding box of each geometry in the GeoSeries.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POLYGON ((1 1, 3 1, 3 3, 1 3, 1 1))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.envelope</span>
<span class="sd">        0                        POINT (1 1)</span>
<span class="sd">        1    POLYGON ((1 1,1 3,3 3,3 1,1 1))</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_property_geo</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Envelope</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tests whether each geometry in the GeoSeries is empty.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        Mask of boolean values for each element in the GeoSeries that indicates whether an element is empty.</span>
<span class="sd">            * *True:* The geometry is empty.</span>
<span class="sd">            * *False:* The geometry is not empty.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;LINESTRING EMPTY&quot;, &quot;POINT (100 200)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.is_empty</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_property_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_IsEmpty</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># Geometry related unary methods, which return GeoSeries</span>
    <span class="c1"># -------------------------------------------------------------------------</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">exterior</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry in the GeoSeries, returns a line string representing the exterior ring of the geometry.</span>

<span class="sd">        * For a polygon, the returned geometry is a line string representing its exterior ring.</span>
<span class="sd">        * For other geometries, returns None.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Sequence of line strings.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;LINESTRING (4 0,6 0)&quot;, &quot;POLYGON ((0 0,1 0,1 1,0 1,0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.exterior()</span>
<span class="sd">        0                                None</span>
<span class="sd">        1    LINESTRING (0 0,1 0,1 1,0 1,0 0)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_unary_geo</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_ExteriorRing</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry in the GeoSeries and the corresponding geometry given in ``other``, returns a geometry representing the part of the first geometry that does not intersect with the other.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geometry or GeoSeries</span>
<span class="sd">            The geometry or GeoSeries to calculate the difference from the first GeoSeries.</span>
<span class="sd">            * If ``other`` is a geometry, this function calculates the difference between each geometry in the GeoSeries and ``other``.</span>
<span class="sd">            * If ``other`` is a GeoSeries, this function calculates the difference between each geometry in the GeoSeries and the geometry with the same index in ``other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Sequence of geometries representing the difference between each geometry in the GeoSeries and the corresponding geometry given in ``other``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;LINESTRING (0 0,5 0)&quot;, &quot;MULTIPOINT ((4 0),(6 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;LINESTRING (4 0,6 0)&quot;, &quot;POINT (4 0)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s1.difference(s2)</span>
<span class="sd">        0    LINESTRING (0 0,4 0)</span>
<span class="sd">        1             POINT (6 0)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_binary_geo</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Difference</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">symmetric_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry in the GeoSeries and the corresponding geometry given in ``other``, returns a geometry representing the portions of the two geometries that do not interset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geometry or GeoSeries</span>
<span class="sd">            The geometry or GeoSeries to calculate the symmetric difference from the first GeoSeries.</span>
<span class="sd">            * If ``other`` is a geometry, this function calculates the symmetric difference between each geometry in the GeoSeries and ``other``.</span>
<span class="sd">            * If ``other`` is a GeoSeries, this function calculates the symmetric difference between each geometry in the GeoSeries and the geometry with the same index in ``other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Sequence of geometries representing the symmetric difference between each geometry in the GeoSeries and the corresponding geometry given in ``other``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;LINESTRING (0 0,5 0)&quot;, &quot;MULTIPOINT ((4 0),(6 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;LINESTRING (4 0,6 0)&quot;, &quot;POINT (4 0)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s1.symmetric_difference(s2)</span>
<span class="sd">        0    MULTILINESTRING ((0 0,4 0),(5 0,6 0))</span>
<span class="sd">        1                              POINT (6 0)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_binary_geo</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_SymDifference</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor_x</span><span class="p">,</span> <span class="n">factor_y</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Scales all geometries in the GeoSeries to a new size.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        factor_x : float</span>
<span class="sd">            Scaling factor for x dimension.</span>
<span class="sd">        factor_y : float</span>
<span class="sd">            Scaling factor for y dimension.</span>
<span class="sd">        origin : string or tuple</span>
<span class="sd">            The scale origin.</span>
<span class="sd">            * &#39;center&#39;: The center of 2D bounding box (default).</span>
<span class="sd">            * &#39;centroid&#39;: The geometry&#39;s 2D centroid.</span>
<span class="sd">            * tuple: A coordinate tuple (x, y).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Sequence of scaled geometries.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;LINESTRING (0 0,5 0)&quot;, &quot;MULTIPOINT ((4 0),(6 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s1.scale(2,2)</span>
<span class="sd">        0    LINESTRING (-2.5 0.0,7.5 0.0)</span>
<span class="sd">        1             MULTIPOINT (3 0,7 0)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_unary_geo</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Scale</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">factor_x</span><span class="p">,</span> <span class="n">factor_y</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">affine_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a GeoSeries with transformed geometries.</span>

<span class="sd">        If ``matrix`` is [a, b, d, e, offset_x, offset_y], the transform equation of a point [x, y] is as follows:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \begin{equation}</span>
<span class="sd">                \begin{bmatrix}</span>
<span class="sd">                    x&#39;\\</span>
<span class="sd">                    y&#39;</span>
<span class="sd">                \end{bmatrix}</span>
<span class="sd">                =</span>
<span class="sd">                \begin{bmatrix}</span>
<span class="sd">                    a &amp; b\\</span>
<span class="sd">                    d &amp; e</span>
<span class="sd">                \end{bmatrix}</span>
<span class="sd">                \begin{bmatrix}</span>
<span class="sd">                    x\\</span>
<span class="sd">                    y</span>
<span class="sd">                \end{bmatrix}</span>
<span class="sd">                +</span>
<span class="sd">                \begin{bmatrix}</span>
<span class="sd">                    offset\_x\\</span>
<span class="sd">                    offset\_y</span>
<span class="sd">                \end{bmatrix}</span>
<span class="sd">                =</span>
<span class="sd">                \begin{bmatrix}</span>
<span class="sd">                    ax + by + offset\_x\\</span>
<span class="sd">                    dx + ey + offset\_y</span>
<span class="sd">                \end{bmatrix}</span>
<span class="sd">            \end{equation}</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        matrix: List or tuple</span>
<span class="sd">            A matrix [a, b, d, e, offset_x, offset_y] for 2D transformation.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Sequence of geometries tranformed by ``matrix``.</span>

<span class="sd">        Examples</span>
<span class="sd">        ---------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;LINESTRING (0 0,5 0)&quot;, &quot;MULTIPOINT ((4 0),(6 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; matrix = (2,2,2,2,2,2)</span>
<span class="sd">        &gt;&gt;&gt; s1.affine_transfrom(matrix)</span>
<span class="sd">        0      LINESTRING (2 2,12 12)</span>
<span class="sd">        1    MULTIPOINT (10 10,14 14)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_unary_geo</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Affine</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">matrix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset_x</span><span class="p">,</span> <span class="n">offset_y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a GeoSeries with translated geometries shifted by offsets along each dimension.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        offset_x: float</span>
<span class="sd">            The offset along the X dimension.</span>
<span class="sd">        offset_y: float</span>
<span class="sd">            The offset along the Y dimension.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Sequence of translated geometries.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;LINESTRING (0 0,5 0)&quot;, &quot;MULTIPOINT ((4 0),(6 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s1.translate(2,1)</span>
<span class="sd">        0    LINESTRING (2 1,7 1)</span>
<span class="sd">        1    MULTIPOINT (6 1,8 1)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_unary_geo</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Translate</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">offset_x</span><span class="p">,</span> <span class="n">offset_y</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="n">use_radians</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a GeoSeries with rotated geometries on a 2D plane.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        angle: float</span>
<span class="sd">            The angle of rotation. It can be specified in either degrees (default) or radians by setting ``use_radians=True``.</span>
<span class="sd">            * Positive angle: Counter-clockwise rotation.</span>
<span class="sd">            * Negative angle: Clockwise rotation.</span>
<span class="sd">        origin: string or tuple</span>
<span class="sd">            The rotatation origin.</span>
<span class="sd">            * &#39;center&#39;: The center of 2D bounding box (default).</span>
<span class="sd">            * &#39;centroid&#39;: The geometry&#39;s 2D centroid.</span>
<span class="sd">            * tuple: A coordinate tuple (x, y).</span>
<span class="sd">        use_radians: boolean</span>
<span class="sd">            Whether to interpret the angle of rotation as degrees or radians.</span>
<span class="sd">            * *True:* Use angle in radians.</span>
<span class="sd">            * *False:* Use angle in degrees.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Sequence of rotated geometries.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;LINESTRING (0 0,5 0)&quot;, &quot;MULTIPOINT ((4 0),(6 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; import math</span>
<span class="sd">        &gt;&gt;&gt; s1.rotate(math.pi, origin=(0, 1), use_radians=True)</span>
<span class="sd">        0     LINESTRING (0.0 2.0,-5.0 2.0)</span>
<span class="sd">        1    MULTIPOINT (-4.0 2.0,-6.0 2.0)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_unary_geo</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Rotate</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span> <span class="n">use_radians</span><span class="o">=</span><span class="n">use_radians</span><span class="p">)</span>

<div class="viewcode-block" id="GeoSeries.curve_to_line"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.curve_to_line.html#arctern.GeoSeries.curve_to_line">[文档]</a>    <span class="k">def</span> <span class="nf">curve_to_line</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts curves in each geometry to approximate linear representations.</span>

<span class="sd">        For example,</span>

<span class="sd">        * CIRCULAR STRING to LINESTRING,</span>
<span class="sd">        * CURVEPOLYGON to POLYGON,</span>
<span class="sd">        * MULTISURFACE to MULTIPOLYGON.</span>

<span class="sd">        It is useful for outputting to devices that can&#39;t support CIRCULARSTRING geometry types.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Converted linear geometries.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; rst = s.curve_to_line().to_wkt()</span>
<span class="sd">        &gt;&gt;&gt; assert str(rst[0]).startswith(&quot;POLYGON&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_unary_geo</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_CurveToLine</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.to_crs"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.to_crs.html#arctern.GeoSeries.to_crs">[文档]</a>    <span class="k">def</span> <span class="nf">to_crs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transforms the Coordinate Reference System (CRS) of the GeoSeries to ``crs``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        crs : str</span>
<span class="sd">            A string representation of CRS.</span>
<span class="sd">            The string is made up of an authority code and a SRID (Spatial Reference Identifier), for example, &quot;EPSG:4326&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            GeoSeries with transformed CRS.</span>

<span class="sd">        Notes</span>
<span class="sd">        -------</span>
<span class="sd">        Arctern supports common CRSs listed at the `Spatial Reference &lt;https://spatialreference.org/&gt;`_ website.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT (1 2)&quot;], crs=&quot;EPSG:4326&quot;)</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    POINT (1 2)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &gt;&gt;&gt; s.to_crs(crs=&quot;EPSG:3857&quot;)</span>
<span class="sd">        0    POINT (111319.490793274 222684.208505545)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can not transform with invalid crs&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Can not transform geometries without crs. Set crs for this GeoSeries first.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span> <span class="o">==</span> <span class="n">crs</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">_unary_geo</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Transform</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span> <span class="n">crs</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.simplify"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.simplify.html#arctern.GeoSeries.simplify">[文档]</a>    <span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a simplified version for each geometry in the GeoSeries using the `Douglas-Peucker algorithm &lt;https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm&gt;`_.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tolerance : float</span>
<span class="sd">            Distance tolerance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Sequence of simplified geometries.</span>

<span class="sd">        Examples</span>
<span class="sd">        .. doctest::</span>
<span class="sd">           :skipif: True</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; from arctern.plot import plot_geometry</span>
<span class="sd">        &gt;&gt;&gt; g0 = GeoSeries([&quot;CURVEPOLYGON(CIRCULARSTRING(0 0, 10 0, 10 10, 0 10, 0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; g0 = g0.curve_to_line()</span>
<span class="sd">        &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">        &gt;&gt;&gt; ax.axis(&#39;equal&#39;) # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; ax.grid()</span>
<span class="sd">        &gt;&gt;&gt; plot_geometry(ax,g0,facecolor=&quot;red&quot;,alpha=0.2)</span>
<span class="sd">        &gt;&gt;&gt; plot_geometry(ax,g0.simplify(1),facecolor=&quot;green&quot;,alpha=0.2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_unary_geo</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_SimplifyPreserveTopology</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.buffer"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.buffer.html#arctern.GeoSeries.buffer">[文档]</a>    <span class="k">def</span> <span class="nf">buffer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry, moves all of its points away from its centroid to construct a new geometry. The distance of movement is specified as ``distance``.</span>

<span class="sd">        * If ``distance`` &gt; 0, the new geometry is a scaled-up version outside the original geometry.</span>
<span class="sd">        * If ``distance`` &lt; 0, the new geometry is a scaled-down version inside the original geometry.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        distance : float</span>
<span class="sd">            Distance of movement.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Sequence of geometries.</span>

<span class="sd">        Examples</span>
<span class="sd">        .. doctest::</span>
<span class="sd">           :skipif: True</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; from arctern.plot import plot_geometry</span>
<span class="sd">        &gt;&gt;&gt; g0 = GeoSeries([&quot;CURVEPOLYGON(CIRCULARSTRING(0 0, 10 0, 10 10, 0 10, 0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; g0 = g0.curve_to_line()</span>
<span class="sd">        &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">        &gt;&gt;&gt; ax.axis(&#39;equal&#39;) # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; ax.grid()</span>
<span class="sd">        &gt;&gt;&gt; plot_geometry(ax,g0,facecolor=[&quot;red&quot;],alpha=0.2)</span>
<span class="sd">        &gt;&gt;&gt; plot_geometry(ax,g0.buffer(-2),facecolor=[&quot;green&quot;],alpha=0.2)</span>
<span class="sd">        &gt;&gt;&gt; plot_geometry(ax,g0.buffer(2),facecolor=[&quot;blue&quot;],alpha=0.2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_unary_geo</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Buffer</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.precision_reduce"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.precision_reduce.html#arctern.GeoSeries.precision_reduce">[文档]</a>    <span class="k">def</span> <span class="nf">precision_reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precision</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For the coordinates of each geometry in the GeoSeries, reduces the number of significant digits to the given number. The digit in the last decimal place will be rounded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        precision : int</span>
<span class="sd">            Number of significant digits.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Sequence of geometries with reduced precision.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT (1.333 2.666)&quot;, &quot;POINT (2.655 4.447)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.precision_reduce(3)</span>
<span class="sd">        0    POINT (1.33 2.67)</span>
<span class="sd">        1    POINT (2.66 4.45)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_unary_geo</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_PrecisionReduce</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">precision</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.make_valid"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.make_valid.html#arctern.GeoSeries.make_valid">[文档]</a>    <span class="k">def</span> <span class="nf">make_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a valid representation of each geometry in the GeoSeries without losing any of the input vertices.</span>

<span class="sd">        If the geometry is already-valid, then nothing will be done. If the geometry can&#39;t be made to valid, it will be set to None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Sequence of valid geometries.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">        &gt;&gt;&gt; pd.set_option(&quot;max_colwidth&quot;, 1000)</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POLYGON ((2 1,3 1,3 2,2 2,2 8,2 1))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.make_valid()</span>
<span class="sd">        0    GEOMETRYCOLLECTION (POLYGON ((2 2,3 2,3 1,2 1,2 2)),LINESTRING (2 2,2 8))</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_unary_geo</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_MakeValid</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.unary_union"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.unary_union.html#arctern.GeoSeries.unary_union">[文档]</a>    <span class="k">def</span> <span class="nf">unary_union</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates a geometry that represents the union of all geometries in the GeoSeries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            A GeoSeries that contains only one geometry, which is the union of all geometries in the GeoSeries.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; p1 = &quot;POINT(1 2)&quot;</span>
<span class="sd">        &gt;&gt;&gt; p2 = &quot;POINT(1 1)&quot;</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([p1, p2])</span>
<span class="sd">        &gt;&gt;&gt; s.unary_union()</span>
<span class="sd">        0    MULTIPOINT (1 2,1 1)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">GeoSeries</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Union_Aggr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>

<div class="viewcode-block" id="GeoSeries.envelope_aggr"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.envelope_aggr.html#arctern.GeoSeries.envelope_aggr">[文档]</a>    <span class="k">def</span> <span class="nf">envelope_aggr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the minimum bounding box for the union of all geometries in the GeoSeries.</span>

<span class="sd">        The bounding box is a rectangular geometry object, and its sides are parallel to the axes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            A GeoSeries that contains only one geometry, which is the minimum bounding box for the union of all geometries in the GeoSeries.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; p1 = &quot;POLYGON ((0 0,4 0,4 4,0 4,0 0))&quot;</span>
<span class="sd">        &gt;&gt;&gt; p2 = &quot;POLYGON ((5 1,7 1,7 2,5 2,5 1))&quot;</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([p1, p2])</span>
<span class="sd">        &gt;&gt;&gt; s.envelope_aggr()</span>
<span class="sd">        0    POLYGON ((0 0,0 4,7 4,7 0,0 0))</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">GeoSeries</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Envelope_Aggr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>

    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># Geometry related binary methods, which return Series[bool/float]</span>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="GeoSeries.intersects"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.intersects.html#arctern.GeoSeries.intersects">[文档]</a>    <span class="k">def</span> <span class="nf">intersects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry in the GeoSeries and the corresponding geometry given in ``other``, tests whether they intersect each other.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geometry or GeoSeries</span>
<span class="sd">            The geometry or GeoSeries to test whether it is intersected with the geometries in the first GeoSeries.</span>

<span class="sd">            * If ``other`` is a geometry, this function tests the intersection relation between each geometry in the GeoSeries and ``other``.</span>
<span class="sd">            * If ``other`` is a GeoSeries, this function tests the intersection relation between each geometry in the GeoSeries and the geometry with the same index in ``other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Mask of boolean values for each element in the GeoSeries that indicates whether it intersects the geometries in ``other``.</span>

<span class="sd">            * *True*: The two geometries intersect each other.</span>
<span class="sd">            * *False*: The two geometries do not intersect each other.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON((0 0,1 0,1 1,0 1,0 0))&quot;, &quot;POLYGON((8 0,9 0,9 1,8 1,8 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;, &quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.intersects(s1)</span>
<span class="sd">        0    True</span>
<span class="sd">        1    True</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        Alternatively, ``other`` can be a geometry in WKB format.</span>

<span class="sd">        &gt;&gt;&gt; s2.intersects(s1[0])</span>
<span class="sd">        0    True</span>
<span class="sd">        1    True</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_binary_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Intersects</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">disjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry in the GeoSeries and the corresponding geometry given in ``other``, tests whether they do not intersect each other.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geometry or GeoSeries</span>
<span class="sd">            The geometry or GeoSeries to test whether it is not intersected with the geometries in the first GeoSeries.</span>
<span class="sd">            * If ``other`` is a geometry, this function tests the intersection relation between each geometry in the GeoSeries and ``other``.</span>
<span class="sd">            * If ``other`` is a GeoSeries, this function tests the intersection relation between each geometry in the GeoSeries and the geometry with the same index in ``other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Mask of boolean values for each element in the GeoSeries that indicates whether it intersects the geometries in ``other``.</span>
<span class="sd">            * *True*: The two geometries do not intersect each other.</span>
<span class="sd">            * *False*: The two geometries intersect each other.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON((0 0,1 0,1 1,0 1,0 0))&quot;, &quot;POLYGON((8 0,9 0,9 1,8 1,8 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;, &quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.disjoint(s1)</span>
<span class="sd">        0    False</span>
<span class="sd">        1    False</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_binary_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Disjoint</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="GeoSeries.within"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.within.html#arctern.GeoSeries.within">[文档]</a>    <span class="k">def</span> <span class="nf">within</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry in the GeoSeries and the corresponding geometry given in ``other``, tests whether the first geometry is within the other.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geometry or GeoSeries</span>
<span class="sd">            The geometry or GeoSeries to test whether the geometries in the first GeoSeries is within it.</span>

<span class="sd">            * If ``other`` is a geometry, this function tests the &quot;within&quot; relation between each geometry in the GeoSeries and ``other``.</span>
<span class="sd">            * If ``other`` is a GeoSeries, this function tests the &quot;within&quot; relation between each geometry in the GeoSeries and the geometry with the same index in ``other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Mask of boolean values for each element in the GeoSeries that indicates whether it is within the geometries in ``other``.</span>
<span class="sd">            * *True*: The first geometry is within the other.</span>
<span class="sd">            * *False*: The first geometry is not within the other.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON((0 0,1 0,1 1,0 1,0 0))&quot;, &quot;POLYGON((8 0,9 0,9 1,8 1,8 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;, &quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.within(s1)</span>
<span class="sd">        0    False</span>
<span class="sd">        1    False</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_binary_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Within</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.contains"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.contains.html#arctern.GeoSeries.contains">[文档]</a>    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry in the GeoSeries and the corresponding geometry given in ``other``, tests whether the first geometry contains the other.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geometry or GeoSeries</span>
<span class="sd">            The geometry or GeoSeries to test whether the geometries in the first GeoSeries contains it.</span>

<span class="sd">            * If ``other`` is a geometry, this function tests the &quot;contain&quot; relation between each geometry in the GeoSeries and ``other``.</span>
<span class="sd">            * If ``other`` is a GeoSeries, this function tests the &quot;contain&quot; relation between each geometry in the GeoSeries and the geometry with the same index in ``other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Mask of boolean values for each element in the GeoSeries that indicates whether it contains the geometries in ``other``.</span>

<span class="sd">            * *True*: The first geometry contains the other.</span>
<span class="sd">            * *False*: The first geometry does not contain the other.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON((0 0,1 0,1 1,0 1,0 0))&quot;, &quot;POLYGON((8 0,9 0,9 1,8 1,8 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;, &quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.contains(s1)</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_binary_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Contains</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.crosses"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.crosses.html#arctern.GeoSeries.crosses">[文档]</a>    <span class="k">def</span> <span class="nf">crosses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry in the GeoSeries and the corresponding geometry given in ``other``, tests whether the first geometry spatially crosses the other.</span>

<span class="sd">        &quot;Spatially cross&quot; means two geometries have some, but not all interior points in common. The intersection of the interiors of the geometries must not be the empty set and must have a dimensionality less than the maximum dimension of the two input geometries.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geometry or GeoSeries</span>
<span class="sd">            The geometry or GeoSeries to test whether it crosses the geometries in the first GeoSeries.</span>

<span class="sd">            * If ``other`` is a geometry, this function tests the &quot;cross&quot; relation between each geometry in the GeoSeries and ``other``.</span>
<span class="sd">            * If ``other`` is a GeoSeries, this function tests the &quot;cross&quot; relation between each geometry in the GeoSeries and the geometry with the same index in ``other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Mask of boolean values for each element in the GeoSeries that indicates whether it crosses the geometries in ``other``.</span>

<span class="sd">            * *True*: The first geometry crosses the other.</span>
<span class="sd">            * *False*: The first geometry does not cross the other.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON((0 0,1 0,1 1,0 1,0 0))&quot;, &quot;POLYGON((8 0,9 0,9 1,8 1,8 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;, &quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.crosses(s1)</span>
<span class="sd">        0    False</span>
<span class="sd">        1    False</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_binary_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Crosses</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.geom_equals"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.geom_equals.html#arctern.GeoSeries.geom_equals">[文档]</a>    <span class="k">def</span> <span class="nf">geom_equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry in the GeoSeries and the corresponding geometry given in ``other``, tests whether the first geometry equals the other.</span>

<span class="sd">        &quot;Equal&quot; means two geometries represent the same geometry structure.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geometry or GeoSeries</span>
<span class="sd">            The geometry or GeoSeries to test whether it equals the geometries in the first GeoSeries.</span>

<span class="sd">            * If ``other`` is a geometry, this function tests the equivalence relation between each geometry in the GeoSeries and ``other``.</span>
<span class="sd">            * If ``other`` is a GeoSeries, this function tests the equivalence relation between each geometry in the GeoSeries and the geometry with the same index in ``other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Mask of boolean values for each element in the GeoSeries that indicates whether it equals the geometries in ``other``.</span>

<span class="sd">            * *True*: The first geometry equals the other.</span>
<span class="sd">            * *False*: The first geometry does not equal the other.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON((0 0,1 0,1 1,0 1,0 0))&quot;, &quot;POLYGON((8 0,9 0,9 1,8 1,8 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;, &quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.geom_equals(s1)</span>
<span class="sd">        0    False</span>
<span class="sd">        1    False</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.api.types</span> <span class="kn">import</span> <span class="n">is_scalar</span>
        <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">([</span><span class="n">other</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">this</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The indices of the two GeoSeries are different.&quot;</span><span class="p">)</span>
            <span class="n">this</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_binary_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Equals</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">other_na</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>
        <span class="n">result</span><span class="p">[</span><span class="n">other_na</span> <span class="o">&amp;</span> <span class="n">this</span><span class="o">.</span><span class="n">isna</span><span class="p">()]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="GeoSeries.touches"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.touches.html#arctern.GeoSeries.touches">[文档]</a>    <span class="k">def</span> <span class="nf">touches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry in the GeoSeries and the corresponding geometry given in ``other``, tests whether the first geometry touches the other.</span>

<span class="sd">        &quot;Touch&quot; means two geometries have common points, and the common points locate only on their boundaries.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geometry or GeoSeries</span>
<span class="sd">            The geometry or GeoSeries to test whether it touches the geometries in the first GeoSeries.</span>

<span class="sd">            * If ``other`` is a geometry, this function tests the &quot;touch&quot; relation between each geometry in the GeoSeries and ``other``.</span>
<span class="sd">            * If ``other`` is a GeoSeries, this function tests the &quot;touch&quot; relation between each geometry in the GeoSeries and the geometry with the same index in ``other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Mask of boolean values for each element in the GeoSeries that indicates whether it touches the geometries in ``other``.</span>

<span class="sd">            * *True*: The first geometry touches the other.</span>
<span class="sd">            * *False*: The first geometry does not touch the other.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON((0 0,1 0,1 1,0 1,0 0))&quot;, &quot;POLYGON((8 0,9 0,9 1,8 1,8 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;, &quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.touches(s1)</span>
<span class="sd">        0    False</span>
<span class="sd">        1     True</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_binary_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Touches</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.overlaps"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.overlaps.html#arctern.GeoSeries.overlaps">[文档]</a>    <span class="k">def</span> <span class="nf">overlaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry in the GeoSeries and the corresponding geometry given in ``other``, tests whether the first geometry &quot;spatially overlaps&quot; the other.</span>

<span class="sd">        &quot;Spatially overlap&quot; here means two geometries intersect but one does not completely contain another.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geometry or GeoSeries</span>
<span class="sd">            The geometry or GeoSeries to test whether it overlaps the geometries in the first GeoSeries.</span>

<span class="sd">            * If ``other`` is a geometry, this function tests the &quot;overlap&quot; relation between each geometry in the GeoSeries and ``other``.</span>
<span class="sd">            * If ``other`` is a GeoSeries, this function tests the &quot;overlap&quot; relation between each geometry in the GeoSeries and the geometry with the same index in ``other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Mask of boolean values for each element in the GeoSeries that indicates whether it overlaps the geometries in ``other``.</span>

<span class="sd">            * *True*: The first geometry overlaps the other.</span>
<span class="sd">            * *False*: The first geometry does not overlap the other.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON((0 0,1 0,1 1,0 1,0 0))&quot;, &quot;POLYGON((8 0,9 0,9 1,8 1,8 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;, &quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.overlaps(s1)</span>
<span class="sd">        0    False</span>
<span class="sd">        1    False</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_binary_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Overlaps</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.distance"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.distance.html#arctern.GeoSeries.distance">[文档]</a>    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry in the GeoSeries and the corresponding geometry given in ``other``, calculates the minimum 2D Cartesian (planar) distance between them.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geometry or GeoSeries</span>
<span class="sd">            The geometry or GeoSeries to calculate the distance between it and the geometries in the first GeoSeries.</span>

<span class="sd">            * If ``other`` is a geometry, this function calculates the distance between each geometry in the GeoSeries and ``other``.</span>
<span class="sd">            * If ``other`` is a GeoSeries, this function calculates the distance between each geometry in the GeoSeries and the geometry with the same index in ``other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Distance between each geometry in the GeoSeries and the corresponding geometry given in ``other``.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; p11 = &quot;LINESTRING(9 0,9 2)&quot;</span>
<span class="sd">        &gt;&gt;&gt; p12 = &quot;POINT(10 2)&quot;</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([p11, p12])</span>
<span class="sd">        &gt;&gt;&gt; p21 = &quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;</span>
<span class="sd">        &gt;&gt;&gt; p22 = &quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([p21, p22])</span>
<span class="sd">        &gt;&gt;&gt; s2.distance(s1)</span>
<span class="sd">        0    1.0</span>
<span class="sd">        1    2.0</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_binary_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Distance</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.distance_sphere"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.distance_sphere.html#arctern.GeoSeries.distance_sphere">[文档]</a>    <span class="k">def</span> <span class="nf">distance_sphere</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each point in the GeoSeries and the corresponding point given in ``other``, calculates the minimum spherical distance between them.</span>

<span class="sd">        This function uses a spherical earth and radius derived from the spheroid defined by the SRID.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geometry or GeoSeries</span>
<span class="sd">            The geometry or GeoSeries to calculate the spherical distance between it and the geometries in the first GeoSeries.</span>

<span class="sd">            * If ``other`` is a geometry, this function calculates the spherical distance between each geometry in the GeoSeries and ``other``. The ``crs`` of ``other`` is &quot;EPSG:4326&quot; bu default.</span>
<span class="sd">            * If ``other`` is a GeoSeries, this function calculates the spherical distance between each geometry in the GeoSeries and the geometry with the same index in ``other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Spherical distance between each geometry in the GeoSeries and the corresponding geometry given in ``other``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -------</span>
<span class="sd">        Only the longitude and latitude coordinate reference system (&quot;EPSG:4326&quot;) can be used to calculate spherical distance.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POINT(10 2)&quot;], crs=&quot;EPSG:4326&quot;)</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POINT(10 3)&quot;], crs=&quot;EPSG:4326&quot;)</span>
<span class="sd">        &gt;&gt;&gt; s2.distance_sphere(s1)</span>
<span class="sd">        0    111226.3</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span> <span class="o">==</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;crs&quot;</span><span class="p">,</span> <span class="s2">&quot;EPSG:4326&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;EPSG:4326&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only can calculate spherical distance with &#39;EPSG:4326&#39; crs.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_binary_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_DistanceSphere</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.hausdorff_distance"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.hausdorff_distance.html#arctern.GeoSeries.hausdorff_distance">[文档]</a>    <span class="k">def</span> <span class="nf">hausdorff_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each point in the GeoSeries and the corresponding point given in ``other``, calculates the Hausdorff distance between them.</span>

<span class="sd">        Hausdorff distance is a measure of how similar two geometries are.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geometry or GeoSeries</span>
<span class="sd">            The geometry or GeoSeries to calculate the Hausdorff distance between it and the geometries in the first GeoSeries.</span>

<span class="sd">            * If ``other`` is a geometry, this function calculates the Hausdorff distance between each geometry in the GeoSeries and ``other``.</span>
<span class="sd">            * If ``other`` is a GeoSeries, this function calculates the Hausdorff distance between each geometry in the GeoSeries and the geometry with the same index in ``other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Hausdorff distance between each geometry in the GeoSeries and the corresponding geometry given in ``other``.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON((0 0 ,0 1, 1 1, 1 0, 0 0))&quot;, &quot;POINT(0 0)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON((0 0 ,0 2, 1 1, 1 0, 0 0))&quot;, &quot;POINT(0 1)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.hausdorff_distance(s1)</span>
<span class="sd">        0    1.0</span>
<span class="sd">        1    1.0</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_binary_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_HausdorffDistance</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># Geometry related binary methods, which return GeoSeries</span>
    <span class="c1"># -------------------------------------------------------------------------</span>

<div class="viewcode-block" id="GeoSeries.intersection"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.intersection.html#arctern.GeoSeries.intersection">[文档]</a>    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each point in the GeoSeries and the corresponding point given in ``other``, calculates the intersection of them.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geometry or GeoSeries</span>
<span class="sd">            The geometry or GeoSeries to calculate the intersection of it and the geometries in the first GeoSeries.</span>

<span class="sd">            * If ``other`` is a geometry, this function calculates the intersection of each geometry in the GeoSeries and ``other``.</span>
<span class="sd">            * If ``other`` is a GeoSeries, this function calculates the intersection of each geometry in the GeoSeries and the geometry with the same index in ``other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Intersection of each geometry in the GeoSeries and the corresponding geometry given in ``other``.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON ((1 1,1 2,2 2,2 1,1 1))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON ((2 1,3 1,3 2,2 2,2 1))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.intersection(s1)</span>
<span class="sd">        0    LINESTRING (2 2,2 1)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_binary_geo</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Intersection</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns a geometry being a union of two input geometries</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : GeoSeries</span>
<span class="sd">            The GeoSeries to calculate the union of it and the geometries in the first GeoSeries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            A GeoSeries that is the union of each geometry in the GeoSeries and the corresponding geometry given in ``other``.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON((0 0 ,0 1, 1 1, 1 0, 0 0))&quot;, &quot;POINT(0 0)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON((0 0 ,0 2, 1 1, 1 0, 0 0))&quot;, &quot;POINT(0 1)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.union(s1)</span>
<span class="sd">        0    POLYGON ((0 0,0 1,0 2,1 1,1 0,0 0))</span>
<span class="sd">        1                   MULTIPOINT (0 1,0 0)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_binary_geo</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Union</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># utils</span>
    <span class="c1"># -------------------------------------------------------------------------</span>

<div class="viewcode-block" id="GeoSeries.to_wkt"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.to_wkt.html#arctern.GeoSeries.to_wkt">[文档]</a>    <span class="k">def</span> <span class="nf">to_wkt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transforms all geometries in the GeoSeries to `WKT &lt;https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry&gt;`_ strings.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Sequence of geometries in WKT format.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    POINT (1 1)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &gt;&gt;&gt; s.to_wkt()</span>
<span class="sd">        0    POINT (1 1)</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_property_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_AsText</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.to_wkb"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.to_wkb.html#arctern.GeoSeries.to_wkb">[文档]</a>    <span class="k">def</span> <span class="nf">to_wkb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transforms all geometries in the GeoSeries to `WKB &lt;https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry#Well-known_binary&gt;`_ strings.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Sequence of geometries in WKB format.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">        &gt;&gt;&gt; pd.set_option(&quot;max_colwidth&quot;, 1000)</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.to_wkb()</span>
<span class="sd">        0    b&#39;\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\xf0?\x00\x00\x00\x00\x00\x00\xf0?&#39;</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_property_op</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.as_geojson"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.as_geojson.html#arctern.GeoSeries.as_geojson">[文档]</a>    <span class="k">def</span> <span class="nf">as_geojson</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transforms all geometries in the GeoSeries to GeoJSON strings.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Sequence of geometries in GeoJSON format.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    POINT (1 1)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &gt;&gt;&gt; s.as_geojson()</span>
<span class="sd">        0    { &quot;type&quot;: &quot;Point&quot;, &quot;coordinates&quot;: [ 1.0, 1.0 ] }</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_property_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_AsGeoJSON</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.to_geopandas"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.to_geopandas.html#arctern.GeoSeries.to_geopandas">[文档]</a>    <span class="k">def</span> <span class="nf">to_geopandas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transforms an arctern.GeoSeries object to a geopandas.GeoSeries object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        geopandas.GeoSeries</span>
<span class="sd">            A geopandas.GeoSeries object.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    POINT (1 1)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &gt;&gt;&gt; s.to_geopandas()</span>
<span class="sd">        0    POINT (1.00000 1.00000)</span>
<span class="sd">        dtype: geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">geopandas</span>
        <span class="kn">import</span> <span class="nn">shapely</span>

        <span class="k">return</span> <span class="n">geopandas</span><span class="o">.</span><span class="n">GeoSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">shapely</span><span class="o">.</span><span class="n">wkb</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">),</span> <span class="n">crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.polygon_from_envelope"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.polygon_from_envelope.html#arctern.GeoSeries.polygon_from_envelope">[文档]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">polygon_from_envelope</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">min_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs rectangular POLYGON objects within the given spatial range. The edges of the rectangles are parallel to the coordinate axises.</span>

<span class="sd">        ``min_x``, ``min_y``, ``max_x``, and ``max_y`` are Series so that polygons can be created in batch. The number of values in the four Series should be the same.</span>

<span class="sd">        Suppose that the demension of ``min_x`` is *N*, the returned GeoSeries of this function should contains *N* rectangles. The shape and position of the rectangle with index *i* is defined by its bottom left vertex *(min_x[i], min_y[i])* and top right vertex *(max_x[i], max_y[i])*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        min_x : Series</span>
<span class="sd">            The minimum x coordinates of the rectangles.</span>
<span class="sd">        min_y : Series</span>
<span class="sd">            The minimum y coordinates of the rectangles.</span>
<span class="sd">        max_x : Series</span>
<span class="sd">            The maximum x coordinates of the rectangles.</span>
<span class="sd">        max_y : Series</span>
<span class="sd">            The maximum y coordinates of the rectangles.</span>
<span class="sd">        crs : str, optional</span>
<span class="sd">            A string representation of Coordinate Reference System (CRS).</span>
<span class="sd">            The string is made up of an authority code and a SRID (Spatial Reference Identifier), for example, &quot;EPSG:4326&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Sequence of rectangular POLYGON objects within the given spatial range.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from pandas import Series</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; min_x = Series([0.0, 1.0])</span>
<span class="sd">        &gt;&gt;&gt; max_x = Series([2.0, 1.5])</span>
<span class="sd">        &gt;&gt;&gt; min_y = Series([0.0, 1.0])</span>
<span class="sd">        &gt;&gt;&gt; max_y = Series([1.0, 1.5])</span>
<span class="sd">        &gt;&gt;&gt; GeoSeries.polygon_from_envelope(min_x, min_y, max_x, max_y)</span>
<span class="sd">        0                POLYGON ((0 0,0 1,2 1,2 0,0 0))</span>
<span class="sd">        1    POLYGON ((1 1,1.0 1.5,1.5 1.5,1.5 1.0,1 1))</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">crs</span> <span class="o">=</span> <span class="n">_validate_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_PolygonFromEnvelope</span><span class="p">(</span><span class="n">min_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span><span class="p">),</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.point"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.point.html#arctern.GeoSeries.point">[文档]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">point</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs POINT objects based on the given coordinates.</span>

<span class="sd">        ``x`` and ``y`` are Series so that points can be created in batch. The number of values in the two Series should be the same.</span>

<span class="sd">        Suppose that the demension of ``x`` is *N*, the returned GeoSeries of this function should contains *N* points. The position of the *i*th point is defined by its coordinates *(x[i], y[i]).*</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : Series</span>
<span class="sd">            X coordinates of points.</span>
<span class="sd">        y : Series</span>
<span class="sd">            Y coordinates of points.</span>
<span class="sd">        crs : str, optional</span>
<span class="sd">            A string representation of Coordinate Reference System (CRS).</span>
<span class="sd">            The string is made up of an authority code and a SRID (Spatial Reference Identifier), for example, &quot;EPSG:4326&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Sequence of POINT objects.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from pandas import Series</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; x = Series([1.3, 2.5])</span>
<span class="sd">        &gt;&gt;&gt; y = Series([1.3, 2.5])</span>
<span class="sd">        &gt;&gt;&gt; GeoSeries.point(x, y)</span>
<span class="sd">        0    POINT (1.3 1.3)</span>
<span class="sd">        1    POINT (2.5 2.5)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">crs</span> <span class="o">=</span> <span class="n">_validate_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.geom_from_geojson"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.geom_from_geojson.html#arctern.GeoSeries.geom_from_geojson">[文档]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">geom_from_geojson</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">json</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs geometries from GeoJSON strings.</span>

<span class="sd">        ``json`` is Series so that geometries can be created in batch.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        json : Series</span>
<span class="sd">            String representations of geometries in JSON format.</span>
<span class="sd">        crs : str, optional</span>
<span class="sd">            A string representation of Coordinate Reference System (CRS).</span>
<span class="sd">            The string is made up of an authority code and a SRID (Spatial Reference Identifier), for example, &quot;EPSG:4326&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Sequence of geometries.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from pandas import Series</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; json = Series([&#39;{&quot;type&quot;:&quot;LineString&quot;,&quot;coordinates&quot;:[[1,2],[4,5],[7,8]]}&#39;])</span>
<span class="sd">        &gt;&gt;&gt; GeoSeries.geom_from_geojson(json)</span>
<span class="sd">        0    LINESTRING (1 2,4 5,7 8)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">crs</span> <span class="o">=</span> <span class="n">_validate_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_GeomFromGeoJSON</span><span class="p">(</span><span class="n">json</span><span class="p">),</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.from_geopandas"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.from_geopandas.html#arctern.GeoSeries.from_geopandas">[文档]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_geopandas</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs an arctern.GeoSeries object from a geopandas.GeoSeries object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : geopandas.GeoSeries</span>
<span class="sd">            A geopandas.GeoSeries object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        arctern.GeoSeries</span>
<span class="sd">            An arctern.GeoSeries object.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Point, Polygon</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; gpd_s = gpd.GeoSeries([Point(1,1), Polygon(((1,1), (1,2), (2,3), (1,1)))])</span>
<span class="sd">        &gt;&gt;&gt; arctern_s = GeoSeries.from_geopandas(gpd_s)</span>
<span class="sd">        &gt;&gt;&gt; arctern_s</span>
<span class="sd">        0                    POINT (1 1)</span>
<span class="sd">        1    POLYGON ((1 1,1 2,2 3,1 1))</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
        <span class="kn">import</span> <span class="nn">shapely.wkb</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoSeries</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;data must be </span><span class="si">{</span><span class="n">gpd</span><span class="o">.</span><span class="n">GeoSeries</span><span class="si">}</span><span class="s2">, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">crs</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">to_authority</span><span class="p">()</span> <span class="ow">or</span> <span class="n">data</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">source_crs</span><span class="o">.</span><span class="n">to_authority</span><span class="p">()</span>
            <span class="n">crs</span> <span class="o">=</span> <span class="n">crs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="n">crs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">crs</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span>
            <span class="k">return</span> <span class="n">shapely</span><span class="o">.</span><span class="n">wkb</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">)</span></div>


    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_calculate_bbox_from_wkb</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">geom_wkb</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate bounding box for the geom_wkb geometry.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">osgeo</span> <span class="kn">import</span> <span class="n">ogr</span>
        <span class="n">geometry</span> <span class="o">=</span> <span class="n">ogr</span><span class="o">.</span><span class="n">CreateGeometryFromWkb</span><span class="p">(</span><span class="n">geom_wkb</span><span class="p">)</span>
        <span class="n">env</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">GetEnvelope</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">env</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">env</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">env</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">env</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bbox</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate bounding box for the union of all geometries in the GeoSeries.</span>

<span class="sd">        :rtype: a (minx, miny, maxx, maxy) list</span>
<span class="sd">        :return: A list of Arctern.GeoSeries&#39;s bound box.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geom_wkb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">envelope_aggr</span><span class="p">()</span><span class="o">.</span><span class="n">to_wkb</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">GeoSeries</span><span class="o">.</span><span class="n">_calculate_bbox_from_wkb</span><span class="p">(</span><span class="n">geom_wkb</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iterfeatures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="s2">&quot;null&quot;</span><span class="p">,</span> <span class="n">show_bbox</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator that yields feature dictionaries that comply with</span>
<span class="sd">        Arctern.GeoSeries.</span>

<span class="sd">        :type na: str</span>
<span class="sd">        :param na: {&#39;null&#39;, &#39;drop&#39;, &#39;keep&#39;}, default &#39;null&#39;</span>
<span class="sd">            Indicates how to output missing (NaN) values in the GeoDataFrame</span>
<span class="sd">            * null: ouput the missing entries as JSON null</span>
<span class="sd">            * drop: remove the property from the feature. This applies to</span>
<span class="sd">                    each feature individually so that features may have</span>
<span class="sd">                    different properties</span>
<span class="sd">            * keep: output the missing entries as NaN</span>

<span class="sd">        :type show_bbox: bool</span>
<span class="sd">        :param show_bbox: include bbox (bounds box) in the geojson. default False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">json</span>
        <span class="k">if</span> <span class="n">na</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;null&quot;</span><span class="p">,</span> <span class="s2">&quot;drop&quot;</span><span class="p">,</span> <span class="s2">&quot;keep&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown na method </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">na</span><span class="p">))</span>

        <span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">fid</span><span class="p">,</span> <span class="n">geom</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>
            <span class="n">feature</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">fid</span><span class="p">),</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Feature&quot;</span><span class="p">,</span>
                <span class="s2">&quot;properties&quot;</span><span class="p">:</span> <span class="p">{},</span>
                <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">GeoSeries</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span><span class="o">.</span><span class="n">as_geojson</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">geom</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">show_bbox</span><span class="p">:</span>
                <span class="n">feature</span><span class="p">[</span><span class="s2">&quot;bbox&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">GeoSeries</span><span class="o">.</span><span class="n">_calculate_bbox_from_wkb</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span> <span class="k">if</span> <span class="n">geom</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">yield</span> <span class="n">feature</span>

    <span class="c1"># pylint: disable=arguments-differ</span>
    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">show_bbox</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a GeoJSON string representation of the GeoSeries.</span>

<span class="sd">        :type show_bbox: bool</span>
<span class="sd">        :param show_bbox: include bbox (bounds box) in the geojson. default False</span>

<span class="sd">        :param kwargs: that will be passed to json.dumps().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">json</span>
        <span class="n">geo</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;FeatureCollection&quot;</span><span class="p">,</span>
            <span class="s2">&quot;features&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iterfeatures</span><span class="p">(</span><span class="n">na</span><span class="o">=</span><span class="s2">&quot;null&quot;</span><span class="p">,</span> <span class="n">show_bbox</span><span class="o">=</span><span class="n">show_bbox</span><span class="p">)),</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">show_bbox</span><span class="p">:</span>
            <span class="n">geo</span><span class="p">[</span><span class="s2">&quot;bbox&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bbox</span>

        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">geo</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">item</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read a file or OGR dataset to GeoSeries.</span>

<span class="sd">        Supported file format is listed in</span>
<span class="sd">        https://github.com/Toblerity/Fiona/blob/master/fiona/drvsupport.py.</span>

<span class="sd">        :type fp: URI (str or pathlib.Path), or file-like object</span>
<span class="sd">        :param fp: A dataset resource identifier or file object.</span>

<span class="sd">        :type bbox: a (minx, miny, maxx, maxy) tuple</span>
<span class="sd">        :param bbox: Filter for geometries which spatial intersects with by the provided bounding box.</span>

<span class="sd">        :type mask: a GeoSeries(should have same crs), wkb formed bytes or wkt formed string</span>
<span class="sd">        :param mask: Filter for geometries which spatial intersects with by the provided geometry.</span>

<span class="sd">        :param item: int or slice</span>
<span class="sd">        :param item: Load special items by skipping over items or stopping at a specific item.</span>

<span class="sd">        :param kwargs: Keyword arguments to `fiona.open()`. e.g. `layer`, `enabled_drivers`.</span>
<span class="sd">                       see https://fiona.readthedocs.io/en/latest/fiona.html#fiona.open for</span>
<span class="sd">                       more info.</span>

<span class="sd">        :rtype: GeoSeries</span>
<span class="sd">        :return: A GeoSeries read from file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">fiona</span>
        <span class="kn">import</span> <span class="nn">json</span>
        <span class="k">with</span> <span class="n">fiona</span><span class="o">.</span><span class="n">Env</span><span class="p">():</span>
            <span class="k">with</span> <span class="n">fiona</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">as</span> <span class="n">features</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">features</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">crs</span> <span class="o">=</span> <span class="n">features</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;init&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">crs</span> <span class="o">=</span> <span class="n">features</span><span class="o">.</span><span class="n">crs_wkt</span>

                <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)):</span>
                        <span class="n">mask</span> <span class="o">=</span> <span class="n">GeoSeries</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">GeoSeries</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unsupported mask type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">arctern</span><span class="o">.</span><span class="n">ST_AsGeoJSON</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">unary_union</span><span class="p">())</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))):</span>
                    <span class="n">item</span> <span class="o">=</span> <span class="p">(</span><span class="n">item</span><span class="p">,)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                    <span class="n">item</span> <span class="o">=</span> <span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unsupported item type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">features</span> <span class="o">=</span> <span class="n">features</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="n">bbox</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

                <span class="n">geoms</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">features</span><span class="p">:</span>
                    <span class="n">geometry</span> <span class="o">=</span> <span class="n">feature</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span>
                    <span class="n">geoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">geometry</span><span class="p">)</span> <span class="k">if</span> <span class="n">geometry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;{&quot;type&quot;: &quot;null&quot;}&#39;</span><span class="p">)</span>
                <span class="n">geoms</span> <span class="o">=</span> <span class="n">arctern</span><span class="o">.</span><span class="n">ST_GeomFromGeoJSON</span><span class="p">(</span><span class="n">geoms</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>

                <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">geoms</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="s2">&quot;ESRI Shapefile&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Store GeoSeries to a file or OGR dataset.</span>

<span class="sd">        :type fp: URI (str or pathlib.Path), or file-like object</span>
<span class="sd">        :param fp: A dataset resource identifier or file object.</span>

<span class="sd">        :type mode: str, default &quot;w&quot;</span>
<span class="sd">        :param mode: &#39;a&#39; to append, or &#39;w&#39; to write. Not all driver support</span>
<span class="sd">                      append, see &quot;Supported driver list&quot; below for more info.</span>

<span class="sd">        :type driver: str, default &quot;ESRI Shapefile&quot;</span>
<span class="sd">        :param driver: The OGR format driver. It&#39;s  represents a</span>
<span class="sd">                       translator for a specific format. Supported driver is listed in</span>
<span class="sd">                       https://github.com/Toblerity/Fiona/blob/master/fiona/drvsupport.py.</span>

<span class="sd">        :param kwargs: Keyword arguments to `fiona.open()`. e.g. `layer` used to</span>
<span class="sd">                       write data to multi-layer dataset.</span>
<span class="sd">                       see https://fiona.readthedocs.io/en/latest/fiona.html#fiona.open for</span>
<span class="sd">                       more info.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geo_type_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([</span>
            <span class="p">(</span><span class="s2">&quot;ST_POINT&quot;</span><span class="p">,</span> <span class="s2">&quot;Point&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;ST_LINESTRING&quot;</span><span class="p">,</span> <span class="s2">&quot;LineString&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;ST_POLYGON&quot;</span><span class="p">,</span> <span class="s2">&quot;Polygon&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;ST_MULTIPOINT&quot;</span><span class="p">,</span> <span class="s2">&quot;MultiPoint&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;ST_MULTILINESTRING&quot;</span><span class="p">,</span> <span class="s2">&quot;MultiLineString&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;ST_MULTIPOLYGON&quot;</span><span class="p">,</span> <span class="s2">&quot;MultiPolygon&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;ST_GEOMETRYCOLLECTION&quot;</span><span class="p">,</span> <span class="s2">&quot;GeometryCollection&quot;</span><span class="p">)</span>
        <span class="p">])</span>

        <span class="n">geo_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_type</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">geo_type_map</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">geo_types</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">geo_types</span> <span class="o">=</span> <span class="s2">&quot;Unknown&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">geo_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">geo_types</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;properties&quot;</span><span class="p">:</span> <span class="p">{},</span> <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">geo_types</span><span class="p">}</span>
        <span class="c1"># TODO: fiona expected crs like Proj4 style mappings, &quot;EPSG:4326&quot; or WKT representations</span>
        <span class="n">crs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span>
        <span class="kn">import</span> <span class="nn">fiona</span>
        <span class="k">with</span> <span class="n">fiona</span><span class="o">.</span><span class="n">Env</span><span class="p">():</span>
            <span class="k">with</span> <span class="n">fiona</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">driver</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">as</span> <span class="n">sink</span><span class="p">:</span>
                <span class="n">sink</span><span class="o">.</span><span class="n">writerecords</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iterfeatures</span><span class="p">())</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; 版权所有 2020, zilliz
      <span class="lastupdated">
        最后更新于 7月 03, 2020.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>