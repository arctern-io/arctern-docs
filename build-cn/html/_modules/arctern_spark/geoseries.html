

<!DOCTYPE html>
<html class="writer-html5" lang="python" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>arctern_spark.geoseries &mdash; Arctern 0.3.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> Arctern
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../quick_start/quick_start.html">快速开始</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../feature_description/feature_description.html">功能说明</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_reference/api_reference.html">API 参考</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cluster/cluster.html">从单机过渡到分布式</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../restful/restful.html">RESTful 服务</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Arctern</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>arctern_spark.geoseries</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for arctern_spark.geoseries</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (C) 2019-2020 Zilliz. All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="c1"># pylint: disable=protected-access,too-many-public-methods,too-many-branches,too-many-statements</span>
<span class="c1"># pylint: disable=super-init-not-called,unidiomatic-typecheck,unbalanced-tuple-unpacking</span>
<span class="c1"># pylint: disable=too-many-lines,non-parent-init-called</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">pandas.api.types</span> <span class="kn">import</span> <span class="n">is_list_like</span>
<span class="kn">from</span> <span class="nn">pandas.io.formats.printing</span> <span class="kn">import</span> <span class="n">pprint_thing</span>
<span class="kn">import</span> <span class="nn">databricks.koalas</span> <span class="k">as</span> <span class="nn">ks</span>
<span class="kn">from</span> <span class="nn">databricks.koalas</span> <span class="kn">import</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">Series</span><span class="p">,</span> <span class="n">get_option</span>
<span class="kn">from</span> <span class="nn">databricks.koalas.base</span> <span class="kn">import</span> <span class="n">IndexOpsMixin</span>
<span class="kn">from</span> <span class="nn">databricks.koalas.exceptions</span> <span class="kn">import</span> <span class="n">SparkPandasIndexingError</span>
<span class="kn">from</span> <span class="nn">databricks.koalas.internal</span> <span class="kn">import</span> <span class="n">NATURAL_ORDER_COLUMN_NAME</span>
<span class="kn">from</span> <span class="nn">databricks.koalas.series</span> <span class="kn">import</span> <span class="n">REPR_PATTERN</span>
<span class="kn">from</span> <span class="nn">databricks.koalas.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">validate_axis</span><span class="p">,</span>
    <span class="n">validate_bool_kwarg</span><span class="p">,</span> <span class="n">name_like_string</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyspark.sql</span> <span class="kn">import</span> <span class="n">functions</span> <span class="k">as</span> <span class="n">F</span><span class="p">,</span> <span class="n">Column</span>
<span class="kn">from</span> <span class="nn">pyspark.sql.types</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">IntegerType</span><span class="p">,</span>
    <span class="n">LongType</span><span class="p">,</span>
    <span class="n">StringType</span><span class="p">,</span>
    <span class="n">BinaryType</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyspark.sql.window</span> <span class="kn">import</span> <span class="n">Window</span>


<span class="c1"># for unary or binary operation, which return koalas Series.</span>
<span class="k">def</span> <span class="nf">_column_op</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">arctern_spark</span> <span class="kn">import</span> <span class="n">scala_wrapper</span>
    <span class="k">return</span> <span class="n">ks</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">column_op</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">scala_wrapper</span><span class="p">,</span> <span class="n">f</span><span class="p">))(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>


<span class="c1"># for unary or binary operation, which return GeoSeries.</span>
<span class="c1"># pylint: disable=no-value-for-parameter</span>
<span class="k">def</span> <span class="nf">_column_geo</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">arctern_spark</span> <span class="kn">import</span> <span class="n">scala_wrapper</span>
    <span class="n">kss</span> <span class="o">=</span> <span class="n">ks</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">column_op</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">scala_wrapper</span><span class="p">,</span> <span class="n">f</span><span class="p">))(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">GeoSeries</span><span class="p">(</span><span class="n">kss</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_agg</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">kss</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">arctern_spark</span> <span class="kn">import</span> <span class="n">scala_wrapper</span>
    <span class="n">scol</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">scala_wrapper</span><span class="p">,</span> <span class="n">f</span><span class="p">)(</span><span class="n">kss</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">column</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">name_like_string</span><span class="p">(</span><span class="n">kss</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">column_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">sdf</span> <span class="o">=</span> <span class="n">kss</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">_sdf</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">scol</span><span class="p">)</span>
    <span class="n">kdf</span> <span class="o">=</span> <span class="n">sdf</span><span class="o">.</span><span class="n">to_koalas</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">GeoSeries</span><span class="p">(</span><span class="n">first_series</span><span class="p">(</span><span class="n">kdf</span><span class="p">),</span> <span class="n">crs</span><span class="o">=</span><span class="n">kss</span><span class="o">.</span><span class="n">_crs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_validate_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">crs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">crs</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`crs` should be spatial reference identifier string&quot;</span><span class="p">)</span>
    <span class="n">crs</span> <span class="o">=</span> <span class="n">crs</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">if</span> <span class="n">crs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">crs</span>
    <span class="k">return</span> <span class="n">crs</span>


<span class="k">def</span> <span class="nf">_validate_arg</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">arctern_spark</span> <span class="kn">import</span> <span class="n">scala_wrapper</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">scala_wrapper</span><span class="o">.</span><span class="n">st_geomfromtext</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">(</span><span class="nb">bytearray</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)):</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">scala_wrapper</span><span class="o">.</span><span class="n">st_geomfromwkb</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unsupported type </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">arg</span>


<span class="k">def</span> <span class="nf">_validate_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">series_length</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">series_length</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
                <span class="n">series_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="n">args_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">args_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Series</span><span class="p">([</span><span class="n">arg</span><span class="p">]</span> <span class="o">*</span> <span class="n">series_length</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="n">args_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="n">args_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Series</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unsupported type </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">args_list</span>


<div class="viewcode-block" id="GeoSeries"><a class="viewcode-back" href="../../api_reference/cluster_api/api/arctern_spark.GeoSeries.html#arctern_spark.GeoSeries">[docs]</a><span class="k">class</span> <span class="nc">GeoSeries</span><span class="p">(</span><span class="n">Series</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    One-dimensional Series to store an array of geometry objects.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array-like, Iterable, dict, or scalar value(str or bytes)</span>
<span class="sd">        Contains geometric data stored in GeoSeries. The geometric data can be in `WKT &lt;https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry&gt;`_ or `WKB &lt;https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry#Well-known_binary&gt;`_ format.</span>
<span class="sd">        Note that if `data` is a pandas Series, other arguments should not be used.</span>
<span class="sd">    index : array-like or Index (1d)</span>
<span class="sd">        Same to the index of koalas.Series, by default ``RangeIndex (0, 1, 2, …, n)``.</span>
<span class="sd">        Index values must be hashable and have the same length as ``data``. Non-unique index values are allowed. If both a dict and index sequence are used, the index will override the keys found in the dict.</span>
<span class="sd">    dtype :</span>
<span class="sd">        The type of the data. Default: None.</span>
<span class="sd">    name : str, optional</span>
<span class="sd">        The name to give to the GeoSeries.</span>
<span class="sd">    crs : str, optional</span>
<span class="sd">        The Coordinate Reference System (CRS) set to all geometries in GeoSeries.</span>
<span class="sd">        Only supports SRID as a WKT representation of CRS by now, for example, &quot;EPSG:4326&quot;.</span>
<span class="sd">    copy :</span>
<span class="sd">        A boolean value, by default False.</span>

<span class="sd">        * *True:* Copys input data.</span>
<span class="sd">        * *False:* Points to input data.</span>

<span class="sd">    Examples</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">    &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POINT(1 2)&quot;])</span>
<span class="sd">    &gt;&gt;&gt; s</span>
<span class="sd">    0    POINT (1 1)</span>
<span class="sd">    1    POINT (1 2)</span>
<span class="sd">    Name: 0, dtype: object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">assert</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">assert</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">copy</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">fastpath</span>
            <span class="n">anchor</span> <span class="o">=</span> <span class="n">data</span>
            <span class="n">column_label</span> <span class="o">=</span> <span class="n">index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="k">assert</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="k">assert</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="n">copy</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="n">fastpath</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">data</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ks</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="k">assert</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="k">assert</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;crs&quot;</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">crs</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">crs</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">crs</span> <span class="o">==</span> <span class="n">crs</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;crs of the passed geometry data is different from crs.&quot;</span><span class="p">)</span>
                    <span class="n">crs</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">crs</span> <span class="ow">or</span> <span class="n">crs</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">data</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="n">fastpath</span>
                <span class="p">)</span>
                <span class="c1"># The default dtype for empty Series is &#39;float64&#39; in pandas, but it will be object in future.</span>
                <span class="c1"># see https://github.com/pandas-dev/pandas/pull/29405</span>
                <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">empty</span> <span class="ow">and</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">s</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;object&quot;</span><span class="p">)):</span>
                    <span class="c1"># we can&#39;t create an empty pandas series, which dtype can be infered as</span>
                    <span class="c1"># pyspark StringType or Binary Type, so we create a koalas empty series</span>
                    <span class="c1"># and cast it&#39;s type to StringType</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">Series</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
                <span class="n">anchor</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">_anchor</span>
                <span class="n">column_label</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">_column_label</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">anchor</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">column_label</span> <span class="o">=</span> <span class="n">anchor</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">column_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">kss</span> <span class="o">=</span> <span class="n">anchor</span><span class="o">.</span><span class="n">_kser_for</span><span class="p">(</span><span class="n">column_label</span><span class="p">)</span>

            <span class="n">spark_dtype</span> <span class="o">=</span> <span class="n">kss</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">data_type</span>
            <span class="kn">from</span> <span class="nn">arctern_spark.scala_wrapper</span> <span class="kn">import</span> <span class="n">GeometryUDT</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spark_dtype</span><span class="p">,</span> <span class="n">GeometryUDT</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spark_dtype</span><span class="p">,</span> <span class="n">BinaryType</span><span class="p">):</span>
                <span class="n">kss</span> <span class="o">=</span> <span class="n">_column_op</span><span class="p">(</span><span class="s2">&quot;st_geomfromwkb&quot;</span><span class="p">,</span> <span class="n">kss</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spark_dtype</span><span class="p">,</span> <span class="n">StringType</span><span class="p">):</span>
                <span class="n">kss</span> <span class="o">=</span> <span class="n">_column_op</span><span class="p">(</span><span class="s2">&quot;st_geomfromtext&quot;</span><span class="p">,</span> <span class="n">kss</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Can not use no StringType or BinaryType or GeometryUDT data to construct GeoSeries.&quot;</span><span class="p">)</span>
            <span class="n">anchor</span> <span class="o">=</span> <span class="n">kss</span><span class="o">.</span><span class="n">_kdf</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">anchor</span><span class="p">,</span> <span class="s2">&quot;_kseries&quot;</span><span class="p">):</span>
                <span class="n">anchor</span><span class="o">.</span><span class="n">_kseries</span> <span class="o">=</span> <span class="p">{</span><span class="n">column_label</span><span class="p">:</span> <span class="n">kss</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">anchor</span><span class="o">.</span><span class="n">_kseries</span><span class="p">[</span><span class="n">column_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">kss</span>

        <span class="n">IndexOpsMixin</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">anchor</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_column_label</span> <span class="o">=</span> <span class="n">column_label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">]))</span> <span class="ow">or</span> <span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span>
                    <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">data_type</span><span class="p">,</span> <span class="p">(</span><span class="n">IntegerType</span><span class="p">,</span> <span class="n">LongType</span><span class="p">))</span>
            <span class="p">):</span>
                <span class="c1"># Seems like pandas Series always uses int as positional search when slicing</span>
                <span class="c1"># with ints, searches based on index values when the value is int.</span>
                <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">GeoSeries</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">Series</span><span class="p">)</span> <span class="k">else</span> <span class="n">r</span>
            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">GeoSeries</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">Series</span><span class="p">)</span> <span class="k">else</span> <span class="n">r</span>
        <span class="k">except</span> <span class="n">SparkPandasIndexingError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="s2">&quot;Key length (</span><span class="si">{}</span><span class="s2">) exceeds index depth (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_map</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>

<div class="viewcode-block" id="GeoSeries.set_crs"><a class="viewcode-back" href="../../api_reference/cluster_api/api/arctern_spark.GeoSeries.set_crs.html#arctern_spark.GeoSeries.set_crs">[docs]</a>    <span class="k">def</span> <span class="nf">set_crs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the Coordinate Reference System (CRS) for all geometries in GeoSeries.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        crs : str</span>
<span class="sd">            A string representation of CRS.</span>
<span class="sd">            The string is made up of an authority code and a SRID (Spatial Reference Identifier), for example, &quot;EPSG:4326&quot;.</span>

<span class="sd">        Notes</span>
<span class="sd">        -------</span>
<span class="sd">        Arctern supports common CRSs listed at the `Spatial Reference &lt;https://spatialreference.org/&gt;`_ website.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POINT(1 2)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.set_crs(&quot;EPSG:4326&quot;)</span>
<span class="sd">        &gt;&gt;&gt; s.crs</span>
<span class="sd">        &#39;EPSG:4326&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">crs</span> <span class="o">=</span> <span class="n">_validate_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_crs</span> <span class="o">=</span> <span class="n">crs</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_gdf&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gdf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gdf</span><span class="o">.</span><span class="n">_crs_for_cols</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_crs</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">crs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Coordinate Reference System (CRS) of the GeoSeries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            CRS of the GeoSeries.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POINT(1 2)&quot;], crs=&quot;EPSG:4326&quot;)</span>
<span class="sd">        &gt;&gt;&gt; s.crs</span>
<span class="sd">        &#39;EPSG:4326&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_crs</span>

    <span class="nd">@crs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">crs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the Coordinate Reference System (CRS) for all geometries in GeoSeries.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        crs : str</span>
<span class="sd">            A string representation of CRS.</span>
<span class="sd">            The string is made up of an authority code and a SRID (Spatial Reference Identifier), for example, &quot;EPSG:4326&quot;.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POINT(1 2)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.set_crs(&quot;EPSG:4326&quot;)</span>
<span class="sd">        &gt;&gt;&gt; s.crs</span>
<span class="sd">        &#39;EPSG:4326&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hasnans</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if it has any missing values. Otherwise, it returns False.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POINT(1 2)&quot;, None])</span>
<span class="sd">        &gt;&gt;&gt; s.hasnans</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">spark_frame</span>
        <span class="n">scol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">column</span>

        <span class="k">return</span> <span class="n">sdf</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">scol</span><span class="o">.</span><span class="n">isNull</span><span class="p">()))</span><span class="o">.</span><span class="n">collect</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">max_display_count</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.max_rows&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">max_display_count</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wkt_ks</span> <span class="o">=</span> <span class="n">_column_op</span><span class="p">(</span><span class="s2">&quot;st_astext&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">wkt_ks</span><span class="o">.</span><span class="n">_to_internal_pandas</span><span class="p">()</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">wkt_ks</span> <span class="o">=</span> <span class="n">_column_op</span><span class="p">(</span><span class="s2">&quot;st_astext&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="n">max_display_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">pser</span> <span class="o">=</span> <span class="n">wkt_ks</span><span class="o">.</span><span class="n">_to_internal_pandas</span><span class="p">()</span>
        <span class="n">pser_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pser</span><span class="p">)</span>
        <span class="n">pser</span> <span class="o">=</span> <span class="n">pser</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="n">max_display_count</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">pser_length</span> <span class="o">&gt;</span> <span class="n">max_display_count</span><span class="p">:</span>
            <span class="n">repr_string</span> <span class="o">=</span> <span class="n">pser</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">rest</span><span class="p">,</span> <span class="n">prev_footer</span> <span class="o">=</span> <span class="n">repr_string</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">REPR_PATTERN</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">prev_footer</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">length</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;length&quot;</span><span class="p">)</span>
                <span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">footer</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Name: </span><span class="si">{name}</span><span class="s2">, dtype: </span><span class="si">{dtype}</span><span class="se">\n</span><span class="s2">Showing only the first </span><span class="si">{length}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pprint_thing</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="n">rest</span> <span class="o">+</span> <span class="n">footer</span>
        <span class="k">return</span> <span class="n">pser</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_with_new_scol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy Koalas Series with the new Spark Column.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scol: the new Spark Column</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            The copied GeoSeries</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Series._with_new_col has a bug in koalas==1.0.0, override this for GeoSeries</span>
        <span class="c1"># see GH1633 https://github.com/databricks/koalas/issues/1633</span>
        <span class="n">internal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kdf</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
            <span class="n">column_labels</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_column_label</span><span class="p">],</span> <span class="n">data_spark_columns</span><span class="o">=</span><span class="p">[</span><span class="n">scol</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">name_like_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_column_label</span><span class="p">))]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">first_series</span><span class="p">(</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">internal</span><span class="p">))</span>

<div class="viewcode-block" id="GeoSeries.fillna"><a class="viewcode-back" href="../../api_reference/cluster_api/api/arctern_spark.GeoSeries.fillna.html#arctern_spark.GeoSeries.fillna">[docs]</a>    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fill NA/NaN values.</span>

<span class="sd">        .. note:: the current implementation of &#39;method&#39; parameter in fillna uses Spark&#39;s Window</span>
<span class="sd">            without specifying partition specification. This leads to move all data into</span>
<span class="sd">            single partition in single machine and could cause serious</span>
<span class="sd">            performance degradation. Avoid this method against very large dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : scalar, dict, Series</span>
<span class="sd">            Value to use to fill holes. alternately a dict/Series of values</span>
<span class="sd">            specifying which value to use for each column.</span>
<span class="sd">            DataFrame is not supported.</span>
<span class="sd">        method : {&#39;backfill&#39;, &#39;bfill&#39;, &#39;pad&#39;, &#39;ffill&#39;, None}, default None</span>
<span class="sd">            Method to use for filling holes in reindexed Series pad / ffill: propagate last valid</span>
<span class="sd">            observation forward to next valid backfill / bfill:</span>
<span class="sd">            use NEXT valid observation to fill gap</span>
<span class="sd">        axis : {0 or `index`}</span>
<span class="sd">            1 and `columns` are not supported.</span>
<span class="sd">        inplace : boolean, default False</span>
<span class="sd">            Fill in place (do not create a new object)</span>
<span class="sd">        limit : int, default None</span>
<span class="sd">            If method is specified, this is the maximum number of consecutive NaN values to</span>
<span class="sd">            forward/backward fill. In other words, if there is a gap with more than this number of</span>
<span class="sd">            consecutive NaNs, it will only be partially filled. If method is not specified,</span>
<span class="sd">            this is the maximum number of entries along the entire axis where NaNs will be filled.</span>
<span class="sd">            Must be greater than 0 if not None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            GeoSeries with NA entries filled.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POINT(1 2)&quot;, None])</span>
<span class="sd">        &gt;&gt;&gt; r = s.fillna(s[0])</span>
<span class="sd">        &gt;&gt;&gt; r</span>
<span class="sd">        0    POINT (1 1)</span>
<span class="sd">        1    POINT (1 2)</span>
<span class="sd">        2    POINT (1 1)</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">validate_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;fillna currently only works for axis=0 or axis=&#39;index&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Must specify a fillna &#39;value&#39; or &#39;method&#39; parameter.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ffill&quot;</span><span class="p">,</span> <span class="s2">&quot;pad&quot;</span><span class="p">,</span> <span class="s2">&quot;backfill&quot;</span><span class="p">,</span> <span class="s2">&quot;bfill&quot;</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Expecting &#39;pad&#39;, &#39;ffill&#39;, &#39;backfill&#39; or &#39;bfill&#39;.&quot;</span><span class="p">)</span>

        <span class="n">scol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">column</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">scol</span><span class="o">.</span><span class="n">isNull</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytearray</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unsupported type </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;limit parameter for value is not support now&quot;</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">_validate_arg</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">scol</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">otherwise</span><span class="p">(</span><span class="n">scol</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ffill&quot;</span><span class="p">,</span> <span class="s2">&quot;pad&quot;</span><span class="p">]:</span>
                <span class="n">func</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">last</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">Window</span><span class="o">.</span><span class="n">currentRow</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">begin</span> <span class="o">=</span> <span class="n">Window</span><span class="o">.</span><span class="n">currentRow</span> <span class="o">-</span> <span class="n">limit</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">begin</span> <span class="o">=</span> <span class="n">Window</span><span class="o">.</span><span class="n">unboundedPreceding</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;bfill&quot;</span><span class="p">,</span> <span class="s2">&quot;backfill&quot;</span><span class="p">]:</span>
                <span class="n">func</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">first</span>
                <span class="n">begin</span> <span class="o">=</span> <span class="n">Window</span><span class="o">.</span><span class="n">currentRow</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="n">Window</span><span class="o">.</span><span class="n">currentRow</span> <span class="o">+</span> <span class="n">limit</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="n">Window</span><span class="o">.</span><span class="n">unboundedFollowing</span>
            <span class="n">part_cols</span> <span class="o">=</span> <span class="p">()</span>
            <span class="n">window</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">Window</span><span class="o">.</span><span class="n">partitionBy</span><span class="p">(</span><span class="o">*</span><span class="n">part_cols</span><span class="p">)</span>
                    <span class="o">.</span><span class="n">orderBy</span><span class="p">(</span><span class="n">NATURAL_ORDER_COLUMN_NAME</span><span class="p">)</span>
                    <span class="o">.</span><span class="n">rowsBetween</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">scol</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">func</span><span class="p">(</span><span class="n">scol</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">window</span><span class="p">))</span><span class="o">.</span><span class="n">otherwise</span><span class="p">(</span><span class="n">scol</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kdf</span><span class="o">.</span><span class="n">_update_internal_frame</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_kdf</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">with_new_spark_column</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_column_label</span><span class="p">,</span> <span class="n">scol</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_with_new_scol</span><span class="p">(</span><span class="n">scol</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ks</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">column_op</span><span class="p">(</span><span class="n">Column</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_validate_arg</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ks</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">column_op</span><span class="p">(</span><span class="n">Column</span><span class="o">.</span><span class="fm">__ne__</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_validate_arg</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># Geometry related property</span>
    <span class="c1"># -------------------------------------------------------------------------</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the 2D Cartesian (planar) area of each geometry in the GeoSeries.</span>

<span class="sd">        The ways to calculate the area of geometries are as follows:</span>

<span class="sd">        * POINT / MULTIPOINT / LINESTRING / MULTILINESTRING / CIRCULARSTRING: 0</span>
<span class="sd">        * POLYGON: Area of a single polygon.</span>
<span class="sd">        * MULTIPOLYGON: Sum of area of multiple polygons.</span>
<span class="sd">        * CURVEPOLYGON: Area of a single curvilinear polygon.</span>
<span class="sd">        * MULTICURVE: Sum of area of multiple curvilinear polygons.</span>
<span class="sd">        * MULTISURFACE / COMPOUNDCURVE / GEOMETRYCOLLECTION: For a geometry collection among the 3 types, calculates the sum of area of all geometries in the collection.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Koalas Series</span>
<span class="sd">            2D Cartesian (planar) area of each geometry in the GeoSeries.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POLYGON ((1 1, 3 1, 3 3, 1 3, 1 1))&quot;, None])</span>
<span class="sd">        &gt;&gt;&gt; s.area</span>
<span class="sd">        0    0.0</span>
<span class="sd">        1    4.0</span>
<span class="sd">        2    NaN</span>
<span class="sd">        Name: 0, dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_op</span><span class="p">(</span><span class="s2">&quot;st_area&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tests whether each geometry in the GeoSeries is in valid format, such as WKT and WKB formats.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Koalas Series</span>
<span class="sd">            Mask of boolean values for each element in the GeoSeries that indicates whether an element is valid.</span>

<span class="sd">            * *True:* The geometry is valid.</span>
<span class="sd">            * *False:* The geometry is invalid.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POLYGON ((1 1, 3 1, 3 3, 1 3, 1 1))&quot;, &quot;POLYGON ((0 0 , 1 1, 1 0, 0 0))&quot;, &quot;POINT (1)&quot;, None])</span>
<span class="sd">        &gt;&gt;&gt; s.is_valid</span>
<span class="sd">        0     True</span>
<span class="sd">        1     True</span>
<span class="sd">        2     True</span>
<span class="sd">        3     True</span>
<span class="sd">        4    False</span>
<span class="sd">        Name: 0, dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_op</span><span class="p">(</span><span class="s2">&quot;st_isvalid&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the length of each geometry in the GeoSeries.</span>

<span class="sd">        The ways to calculate the length of geometries are as follows:</span>

<span class="sd">        * POINT / MULTIPOINT / POLYGON / MULTIPOLYGON / CURVEPOLYGON / MULTICURVE: 0</span>
<span class="sd">        * LINESTRING: Length of a single straight line.</span>
<span class="sd">        * MULTILINESTRING: Sum of length of multiple straight lines.</span>
<span class="sd">        * CIRCULARSTRING: Length of a single curvilinear line.</span>
<span class="sd">        * MULTISURFACE / COMPOUNDCURVE / GEOMETRYCOLLECTION: For a geometry collection among the 3 types, calculates the sum of length of all geometries in the collection.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Koalas Series</span>
<span class="sd">            Length of each geometry in the GeoSeries.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT (1 1)&quot;, &quot;LINESTRING (2 0, 2 2, 2 6)&quot;, &quot;POLYGON ((3 3, 7 3, 7 7, 3 7, 3 3))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.length</span>
<span class="sd">        0    0.0</span>
<span class="sd">        1    6.0</span>
<span class="sd">        2    0.0</span>
<span class="sd">        Name: 0, dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_op</span><span class="p">(</span><span class="s2">&quot;st_length&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_simple</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tests whether each geometry in the GeoSeries is simple.</span>

<span class="sd">        Here &quot;simple&quot; means that a geometry has no anomalous point, such as a self-intersection or a self-tangency.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Koalas Series</span>
<span class="sd">            Mask of boolean values for each element in the GeoSeries that indicates whether an element is simple.</span>

<span class="sd">            * *True:* The geometry is simple.</span>
<span class="sd">            * *False:* The geometry is not simple.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT (1 1)&quot;, &quot;LINESTRING (2 0, 2 2, 2 6)&quot;, &quot;POLYGON ((3 3, 7 3, 7 7, 3 7, 3 3))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.is_simple</span>
<span class="sd">        0    True</span>
<span class="sd">        1    True</span>
<span class="sd">        2    True</span>
<span class="sd">        Name: 0, dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_op</span><span class="p">(</span><span class="s2">&quot;st_issimple&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">geom_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the type of each geometry in the GeoSeries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Koalas Series</span>
<span class="sd">            The string representations of geometry types. For example, &quot;ST_LINESTRING&quot;, &quot;ST_POLYGON&quot;, &quot;ST_POINT&quot;, and &quot;ST_MULTIPOINT&quot;.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT (1 1)&quot;, &quot;LINESTRING (2 0, 2 2, 2 6)&quot;, &quot;POLYGON ((3 3, 7 3, 7 7, 3 7, 3 3))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.geom_type</span>
<span class="sd">        0         Point</span>
<span class="sd">        1    LineString</span>
<span class="sd">        2       Polygon</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_op</span><span class="p">(</span><span class="s2">&quot;st_geometrytype&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the centroid of each geometry in the GeoSeries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            The centroid of each geometry in the GeoSeries.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT (1 1)&quot;, &quot;LINESTRING (2 0, 2 2, 2 6)&quot;, &quot;POLYGON ((3 3, 7 3, 7 7, 3 7, 3 3))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.centroid</span>
<span class="sd">        0    POINT (1 1)</span>
<span class="sd">        1    POINT (2 3)</span>
<span class="sd">        2    POINT (5 5)</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_geo</span><span class="p">(</span><span class="s2">&quot;st_centroid&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_crs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">convex_hull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry in the GeoSeries, returns the smallest convex geometry that encloses it.</span>

<span class="sd">        * For a polygon, the returned geometry is the smallest convex geometry that encloses it.</span>
<span class="sd">        * For a geometry collection, the returned geometry is the smallest convex geometry that encloses all geometries in the collection.</span>
<span class="sd">        * For a point or line, the returned geometry is the same as the original.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Sequence of convex geometries.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(2 0.5)&quot;, &quot;LINESTRING(0 0,3 0.5)&quot;,  &quot;POLYGON ((1 1,3 1,3 3,1 3, 1 1))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.convex_hull</span>
<span class="sd">        0                          POINT (2 0.5)</span>
<span class="sd">        1                LINESTRING (0 0, 3 0.5)</span>
<span class="sd">        2    POLYGON ((1 1, 1 3, 3 3, 3 1, 1 1))</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_geo</span><span class="p">(</span><span class="s2">&quot;st_convexhull&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_crs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">npoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of points for each geometry in the GeoSeries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Koalas Series</span>
<span class="sd">            Number of points of each geometry in the GeoSeries.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(2 0.5)&quot;, &quot;LINESTRING(0 0,3 0.5)&quot;,  &quot;POLYGON ((1 1,3 1,3 3,1 3, 1 1))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.npoints</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        2    5</span>
<span class="sd">        Name: 0, dtype: int32</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_op</span><span class="p">(</span><span class="s2">&quot;st_npoints&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">envelope</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the minimum bounding box for each geometry in the GeoSeries.</span>

<span class="sd">        The bounding box is a rectangular geometry object, and its edges are parallel to the axes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Minimum bounding box of each geometry in the GeoSeries.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT (1 1)&quot;, &quot;LINESTRING (0 2, 2 2, 2 6)&quot;, &quot;POLYGON ((3 3, 7 3, 7 7, 3 7, 3 3))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.envelope</span>
<span class="sd">        0                            POINT (1 1)</span>
<span class="sd">        1    POLYGON ((0 2, 0 6, 2 6, 2 2, 0 2))</span>
<span class="sd">        2    POLYGON ((3 3, 3 7, 7 7, 7 3, 3 3))</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_geo</span><span class="p">(</span><span class="s2">&quot;st_envelope&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_crs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">exterior</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry in the GeoSeries, returns a line string representing the exterior ring of the geometry.</span>

<span class="sd">        * For a polygon, the returned geometry is a line string representing its exterior ring.</span>
<span class="sd">        * For other geometries, returns None.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Sequence of line strings.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT (1 1)&quot;, &quot;LINESTRING (0 2, 2 2, 2 6)&quot;, &quot;POLYGON ((3 3, 7 3, 7 7, 3 7, 3 3))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.exterior</span>
<span class="sd">        0                                    None</span>
<span class="sd">        1                                    None</span>
<span class="sd">        2    LINESTRING (3 3, 7 3, 7 7, 3 7, 3 3)</span>
<span class="sd">        Name: 0, dtype: object</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_geo</span><span class="p">(</span><span class="s2">&quot;st_exteriorring&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tests whether each geometry in the GeoSeries is empty.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        Mask of boolean values for each element in the GeoSeries that indicates whether an element is empty.</span>
<span class="sd">            * *True:* The geometry is empty.</span>
<span class="sd">            * *False:* The geometry is not empty.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;LINESTRING EMPTY&quot;, &quot;POINT (1 1)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.is_empty</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        Name: 0, dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_op</span><span class="p">(</span><span class="s2">&quot;st_isempty&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the closure of the combinatorial boundary of each geometry in the GeoSeries.</span>

<span class="sd">        * For a polygon, the returned geometry is the same as the original.</span>
<span class="sd">        * For a geometry collection, the returned geometry is the combinatorial boundary of all geometries in the collection.</span>
<span class="sd">        * For a point or line, the returned geometry is an empty geometry collection.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            The boundary (low-dimension) of each geometry in the GeoSeries.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POLYGON ((1 1, 3 1, 3 3, 1 3, 1 1))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.boundary</span>
<span class="sd">        0                GEOMETRYCOLLECTION EMPTY</span>
<span class="sd">        1    LINESTRING (1 1, 3 1, 3 3, 1 3, 1 1)</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_geo</span><span class="p">(</span><span class="s2">&quot;st_boundary&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># Geometry related unary methods, which return GeoSeries</span>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="GeoSeries.make_valid"><a class="viewcode-back" href="../../api_reference/cluster_api/api/arctern_spark.GeoSeries.make_valid.html#arctern_spark.GeoSeries.make_valid">[docs]</a>    <span class="k">def</span> <span class="nf">make_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a valid representation of each geometry in the GeoSeries without losing any of the input vertices.</span>

<span class="sd">        If the geometry is already-valid, then nothing will be done. If the geometry can&#39;t be made to valid, it will be set to None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Sequence of valid geometries.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">        &gt;&gt;&gt; pd.set_option(&quot;max_colwidth&quot;, 1000)</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POLYGON ((2 1,3 1,3 2,2 2,2 8,2 1))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.make_valid()</span>
<span class="sd">        0    POLYGON ((2 1, 3 1, 3 2, 2 2, 2 8, 2 1))</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_geo</span><span class="p">(</span><span class="s2">&quot;st_makevalid&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_crs</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.precision_reduce"><a class="viewcode-back" href="../../api_reference/cluster_api/api/arctern_spark.GeoSeries.precision_reduce.html#arctern_spark.GeoSeries.precision_reduce">[docs]</a>    <span class="k">def</span> <span class="nf">precision_reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precision</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For the coordinates of each geometry in the GeoSeries, reduces the number of significant digits to the given number. The digit in the last decimal place will be rounded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        precision : int</span>
<span class="sd">            Number of significant digits.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Sequence of geometries with reduced precision.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT (1.3333 2.6666)&quot;, &quot;POINT (2.6555 4.4447)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.precision_reduce(3)</span>
<span class="sd">        0    POINT (1.333 2.667)</span>
<span class="sd">        1    POINT (2.656 4.445)</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_geo</span><span class="p">(</span><span class="s2">&quot;st_precisionreduce&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">precision</span><span class="p">),</span> <span class="n">crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_crs</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.unary_union"><a class="viewcode-back" href="../../api_reference/cluster_api/api/arctern_spark.GeoSeries.unary_union.html#arctern_spark.GeoSeries.unary_union">[docs]</a>    <span class="k">def</span> <span class="nf">unary_union</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates a geometry that represents the union of all geometries in the GeoSeries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            A GeoSeries that contains only one geometry, which is the union of all geometries in the GeoSeries.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; p1 = &quot;POINT(1 2)&quot;</span>
<span class="sd">        &gt;&gt;&gt; p2 = &quot;POINT(1 1)&quot;</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([p1, p2])</span>
<span class="sd">        &gt;&gt;&gt; s.unary_union()</span>
<span class="sd">        0    MULTIPOINT ((1 1), (1 2))</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_agg</span><span class="p">(</span><span class="s2">&quot;st_union_aggr&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.envelope_aggr"><a class="viewcode-back" href="../../api_reference/cluster_api/api/arctern_spark.GeoSeries.envelope_aggr.html#arctern_spark.GeoSeries.envelope_aggr">[docs]</a>    <span class="k">def</span> <span class="nf">envelope_aggr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the minimum bounding box for the union of all geometries in the GeoSeries.</span>

<span class="sd">        The bounding box is a rectangular geometry object, and its sides are parallel to the axes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            A GeoSeries that contains only one geometry, which is the minimum bounding box for the union of all geometries in the GeoSeries.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POLYGON ((0 0,4 0,4 4,0 4,0 0))&quot;, &quot;POLYGON ((5 1,7 1,7 2,5 2,5 1))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.envelope_aggr()</span>
<span class="sd">        0    POLYGON ((0 0, 0 4, 7 4, 7 0, 0 0))</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_agg</span><span class="p">(</span><span class="s2">&quot;st_envelope_aggr&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.curve_to_line"><a class="viewcode-back" href="../../api_reference/cluster_api/api/arctern_spark.GeoSeries.curve_to_line.html#arctern_spark.GeoSeries.curve_to_line">[docs]</a>    <span class="k">def</span> <span class="nf">curve_to_line</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts curves in each geometry to approximate linear representations.</span>

<span class="sd">        For example,</span>

<span class="sd">        * CIRCULAR STRING to LINESTRING,</span>
<span class="sd">        * CURVEPOLYGON to POLYGON,</span>
<span class="sd">        * MULTISURFACE to MULTIPOLYGON.</span>

<span class="sd">        It is useful for outputting to devices that can&#39;t support CIRCULARSTRING geometry types.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Converted linear geometries.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; rst = s.curve_to_line().to_wkt()</span>
<span class="sd">        &gt;&gt;&gt; assert str(rst[0]).startswith(&quot;POLYGON&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_geo</span><span class="p">(</span><span class="s2">&quot;st_curvetoline&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_crs</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.simplify"><a class="viewcode-back" href="../../api_reference/cluster_api/api/arctern_spark.GeoSeries.simplify.html#arctern_spark.GeoSeries.simplify">[docs]</a>    <span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a simplified version for each geometry in the GeoSeries using the `Douglas-Peucker algorithm &lt;https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm&gt;`_.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tolerance : float</span>
<span class="sd">            Distance tolerance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Sequence of simplified geometries.</span>

<span class="sd">        Examples</span>
<span class="sd">        .. doctest::</span>
<span class="sd">           :skipif: True</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; from arctern.plot import plot_geometry</span>
<span class="sd">        &gt;&gt;&gt; g0 = GeoSeries([&quot;CURVEPOLYGON(CIRCULARSTRING(0 0, 10 0, 10 10, 0 10, 0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; g0 = g0.curve_to_line()</span>
<span class="sd">        &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">        &gt;&gt;&gt; ax.axis(&#39;equal&#39;) # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; ax.grid()</span>
<span class="sd">        &gt;&gt;&gt; plot_geometry(ax,g0,facecolor=&quot;red&quot;,alpha=0.2)</span>
<span class="sd">        &gt;&gt;&gt; plot_geometry(ax,g0.simplify(1),facecolor=&quot;green&quot;,alpha=0.2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_geo</span><span class="p">(</span><span class="s2">&quot;st_simplifypreservetopology&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">tolerance</span><span class="p">),</span> <span class="n">crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_crs</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.buffer"><a class="viewcode-back" href="../../api_reference/cluster_api/api/arctern_spark.GeoSeries.buffer.html#arctern_spark.GeoSeries.buffer">[docs]</a>    <span class="k">def</span> <span class="nf">buffer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry, moves all of its points away from its centroid to construct a new geometry. The distance of movement is specified as ``distance``.</span>

<span class="sd">        * If ``distance`` &gt; 0, the new geometry is a scaled-up version outside the original geometry.</span>
<span class="sd">        * If ``distance`` &lt; 0, the new geometry is a scaled-down version inside the original geometry.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        distance : float</span>
<span class="sd">            Distance of movement.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Sequence of geometries.</span>

<span class="sd">        Examples</span>
<span class="sd">        .. doctest::</span>
<span class="sd">           :skipif: True</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; from arctern.plot import plot_geometry</span>
<span class="sd">        &gt;&gt;&gt; g0 = GeoSeries([&quot;CURVEPOLYGON(CIRCULARSTRING(0 0, 10 0, 10 10, 0 10, 0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; g0 = g0.curve_to_line()</span>
<span class="sd">        &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">        &gt;&gt;&gt; ax.axis(&#39;equal&#39;) # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; ax.grid()</span>
<span class="sd">        &gt;&gt;&gt; plot_geometry(ax,g0,facecolor=[&quot;red&quot;],alpha=0.2)</span>
<span class="sd">        &gt;&gt;&gt; plot_geometry(ax,g0.buffer(-2),facecolor=[&quot;green&quot;],alpha=0.2)</span>
<span class="sd">        &gt;&gt;&gt; plot_geometry(ax,g0.buffer(2),facecolor=[&quot;blue&quot;],alpha=0.2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_geo</span><span class="p">(</span><span class="s2">&quot;st_buffer&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">distance</span><span class="p">),</span> <span class="n">crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_crs</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.to_crs"><a class="viewcode-back" href="../../api_reference/cluster_api/api/arctern_spark.GeoSeries.to_crs.html#arctern_spark.GeoSeries.to_crs">[docs]</a>    <span class="k">def</span> <span class="nf">to_crs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transforms the Coordinate Reference System (CRS) of the GeoSeries to `crs`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        crs : str</span>
<span class="sd">            A string representation of CRS.</span>
<span class="sd">            The string is made up of an authority code and a SRID (Spatial Reference Identifier), for example, ``&quot;EPSG:4326&quot;``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            GeoSeries with transformed CRS.</span>

<span class="sd">        Notes</span>
<span class="sd">        -------</span>
<span class="sd">        Arctern supports common CRSs listed at the `Spatial Reference &lt;https://spatialreference.org/&gt;`_ website.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT (1 2)&quot;], crs=&quot;EPSG:4326&quot;)</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    POINT (1 2)</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &gt;&gt;&gt; s.to_crs(crs=&quot;EPSG:3857&quot;)</span>
<span class="sd">        0    POINT (111319.49079327357 222684.20850554455)</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can not transform with invalid crs&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Can not transform geometries without crs. Set crs for this GeoSeries first.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span> <span class="o">==</span> <span class="n">crs</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">_column_geo</span><span class="p">(</span><span class="s2">&quot;st_transform&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">),</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">crs</span><span class="p">),</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor_x</span><span class="p">,</span> <span class="n">factor_y</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Scales the geometry to a new size by multiplying the ordinates with the corresponding factor parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        factor_x : float</span>
<span class="sd">            Scaling factor for x dimension.</span>
<span class="sd">        factor_y : float</span>
<span class="sd">            Scaling factor for y dimension.</span>

<span class="sd">        origin : string or tuple</span>
<span class="sd">            The point of origin can be a keyword ‘center’ for 2D bounding box center (default), ‘centroid’ for the geometry’s 2D centroid, or a coordinate tuple (x, y).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            A GeoSeries that contains geometries with a new size by multiplying the ordinates with the corresponding factor parameters.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;LINESTRING (0 0,5 0)&quot;, &quot;MULTIPOINT ((4 0),(6 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s1.scale(2,2)</span>
<span class="sd">        0    LINESTRING (-2.5 0, 7.5 0)</span>
<span class="sd">        1     MULTIPOINT ((3 0), (7 0))</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &gt;&gt;&gt; s1.scale(2, 2, (1, 1))</span>
<span class="sd">        0        LINESTRING (-1 -1, 9 -1)</span>
<span class="sd">        1    MULTIPOINT ((7 -1), (11 -1))</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">_column_geo</span><span class="p">(</span><span class="s2">&quot;st_scale&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">factor_x</span><span class="p">),</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">factor_y</span><span class="p">),</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">origin</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">_column_geo</span><span class="p">(</span><span class="s2">&quot;st_scale&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">factor_x</span><span class="p">),</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">factor_y</span><span class="p">),</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">offset_x</span><span class="p">,</span> <span class="n">offset_y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a GeoSeries with transformed geometries.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        a:</span>
<span class="sd">        b:</span>
<span class="sd">        d:</span>
<span class="sd">        e:</span>
<span class="sd">        offset_x:</span>
<span class="sd">        offset_y:</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            A GeoSeries that contains geometries which are tranformed by parameters in matrix.</span>

<span class="sd">        Examples</span>
<span class="sd">        ---------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;LINESTRING (0 0,5 0)&quot;, &quot;MULTIPOINT ((4 0),(6 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s1.affine(2,2,2,2,2,2)</span>
<span class="sd">        0          LINESTRING (2 2, 12 12)</span>
<span class="sd">        1    MULTIPOINT ((10 10), (14 14))</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_geo</span><span class="p">(</span><span class="s2">&quot;st_affine&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">offset_x</span><span class="p">),</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">offset_y</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shifter_x</span><span class="p">,</span> <span class="n">shifter_y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a GeoSeries with translated geometries.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shifter_x : float</span>
<span class="sd">            Amount of offset along x dimension.</span>
<span class="sd">        shifter_y : float</span>
<span class="sd">            Amount of offset along y dimension.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            A GeoSeries with translated geometries which shifted by offsets along each dimension.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;LINESTRING (0 0,5 0)&quot;, &quot;MULTIPOINT ((4 0),(6 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.translate(2, 1)</span>
<span class="sd">        0        LINESTRING (2 1, 7 1)</span>
<span class="sd">        1    MULTIPOINT ((6 1), (8 1))</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_geo</span><span class="p">(</span><span class="s2">&quot;st_translate&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">shifter_x</span><span class="p">),</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">shifter_y</span><span class="p">))</span>

    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># Geometry related binary methods, which return Series[bool/float]</span>
    <span class="c1"># -------------------------------------------------------------------------</span>

<div class="viewcode-block" id="GeoSeries.intersects"><a class="viewcode-back" href="../../api_reference/cluster_api/api/arctern_spark.GeoSeries.intersects.html#arctern_spark.GeoSeries.intersects">[docs]</a>    <span class="k">def</span> <span class="nf">intersects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry in the GeoSeries and the corresponding geometry given in ``other``, tests whether they intersect each other.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geometry or GeoSeries</span>
<span class="sd">            The geometry or GeoSeries to test whether it is intersected with the geometries in the first GeoSeries.</span>

<span class="sd">            * If ``other`` is a geometry, this function tests the intersection relation between each geometry in the GeoSeries and ``other``.</span>
<span class="sd">            * If ``other`` is a GeoSeries, this function tests the intersection relation between each geometry in the GeoSeries and the geometry with the same index in ``other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Koalas Series</span>
<span class="sd">            Mask of boolean values for each element in the GeoSeries that indicates whether it intersects the geometries in ``other``.</span>

<span class="sd">            * *True*: The two geometries intersect each other.</span>
<span class="sd">            * *False*: The two geometries do not intersect each other.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON((0 0,1 0,1 1,0 1,0 0))&quot;, &quot;POLYGON((8 0,9 0,9 1,8 1,8 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;, &quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.intersects(s1)</span>
<span class="sd">        0    True</span>
<span class="sd">        1    True</span>
<span class="sd">        Name: 0, dtype: bool</span>

<span class="sd">        Alternatively, ``other`` can be a geometry in WKB format.</span>

<span class="sd">        &gt;&gt;&gt; s2.intersects(s1[0])</span>
<span class="sd">        0    True</span>
<span class="sd">        1    True</span>
<span class="sd">        Name: 0, dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_op</span><span class="p">(</span><span class="s2">&quot;st_intersects&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">_validate_arg</span><span class="p">(</span><span class="n">other</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.within"><a class="viewcode-back" href="../../api_reference/cluster_api/api/arctern_spark.GeoSeries.within.html#arctern_spark.GeoSeries.within">[docs]</a>    <span class="k">def</span> <span class="nf">within</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry in the GeoSeries and the corresponding geometry given in ``other``, tests whether the first geometry is within the other.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geometry or GeoSeries</span>
<span class="sd">            The geometry or GeoSeries to test whether the geometries in the first GeoSeries is within it.</span>

<span class="sd">            * If ``other`` is a geometry, this function tests the &quot;within&quot; relation between each geometry in the GeoSeries and ``other``.</span>
<span class="sd">            * If ``other`` is a GeoSeries, this function tests the &quot;within&quot; relation between each geometry in the GeoSeries and the geometry with the same index in ``other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Mask of boolean values for each element in the GeoSeries that indicates whether it is within the geometries in ``other``.</span>
<span class="sd">            * *True*: The first geometry is within the other.</span>
<span class="sd">            * *False*: The first geometry is not within the other.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON((0 0,1 0,1 1,0 1,0 0))&quot;, &quot;POLYGON((8 0,9 0,9 1,8 1,8 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;, &quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.within(s1)</span>
<span class="sd">        0    False</span>
<span class="sd">        1    False</span>
<span class="sd">        Name: 0, dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_op</span><span class="p">(</span><span class="s2">&quot;st_within&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">_validate_arg</span><span class="p">(</span><span class="n">other</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.contains"><a class="viewcode-back" href="../../api_reference/cluster_api/api/arctern_spark.GeoSeries.contains.html#arctern_spark.GeoSeries.contains">[docs]</a>    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry in the GeoSeries and the corresponding geometry given in ``other``, tests whether the first geometry contains the other.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geometry or GeoSeries</span>
<span class="sd">            The geometry or GeoSeries to test whether the geometries in the first GeoSeries contains it.</span>

<span class="sd">            * If ``other`` is a geometry, this function tests the &quot;contain&quot; relation between each geometry in the GeoSeries and ``other``.</span>
<span class="sd">            * If ``other`` is a GeoSeries, this function tests the &quot;contain&quot; relation between each geometry in the GeoSeries and the geometry with the same index in ``other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Koalas Series</span>
<span class="sd">            Mask of boolean values for each element in the GeoSeries that indicates whether it contains the geometries in ``other``.</span>

<span class="sd">            * *True*: The first geometry contains the other.</span>
<span class="sd">            * *False*: The first geometry does not contain the other.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON((0 0,1 0,1 1,0 1,0 0))&quot;, &quot;POLYGON((8 0,9 0,9 1,8 1,8 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;, &quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.contains(s1)</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        Name: 0, dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_op</span><span class="p">(</span><span class="s2">&quot;st_contains&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">_validate_arg</span><span class="p">(</span><span class="n">other</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.geom_equals"><a class="viewcode-back" href="../../api_reference/cluster_api/api/arctern_spark.GeoSeries.geom_equals.html#arctern_spark.GeoSeries.geom_equals">[docs]</a>    <span class="k">def</span> <span class="nf">geom_equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry in the GeoSeries and the corresponding geometry given in ``other``, tests whether the first geometry equals the other.</span>

<span class="sd">        &quot;Equal&quot; means two geometries represent the same geometry structure.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geometry or GeoSeries</span>
<span class="sd">            The geometry or GeoSeries to test whether it equals the geometries in the first GeoSeries.</span>

<span class="sd">            * If ``other`` is a geometry, this function tests the equivalence relation between each geometry in the GeoSeries and ``other``.</span>
<span class="sd">            * If ``other`` is a GeoSeries, this function tests the equivalence relation between each geometry in the GeoSeries and the geometry with the same index in ``other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Koalas Series</span>
<span class="sd">            Mask of boolean values for each element in the GeoSeries that indicates whether it equals the geometries in ``other``.</span>

<span class="sd">            * *True*: The first geometry equals the other.</span>
<span class="sd">            * *False*: The first geometry does not equal the other.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON((0 0,1 0,1 1,0 1,0 0))&quot;, &quot;POLYGON((8 0,9 0,9 1,8 1,8 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;, &quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.geom_equals(s1)</span>
<span class="sd">        0    False</span>
<span class="sd">        1    False</span>
<span class="sd">        Name: 0, dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_op</span><span class="p">(</span><span class="s2">&quot;st_equals&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">_validate_arg</span><span class="p">(</span><span class="n">other</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.crosses"><a class="viewcode-back" href="../../api_reference/cluster_api/api/arctern_spark.GeoSeries.crosses.html#arctern_spark.GeoSeries.crosses">[docs]</a>    <span class="k">def</span> <span class="nf">crosses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry in the GeoSeries and the corresponding geometry given in ``other``, tests whether the first geometry spatially crosses the other.</span>

<span class="sd">        &quot;Spatially cross&quot; means two geometries have some, but not all interior points in common. The intersection of the interiors of the geometries must not be the empty set and must have a dimensionality less than the maximum dimension of the two input geometries.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geometry or GeoSeries</span>
<span class="sd">            The geometry or GeoSeries to test whether it crosses the geometries in the first GeoSeries.</span>

<span class="sd">            * If ``other`` is a geometry, this function tests the &quot;cross&quot; relation between each geometry in the GeoSeries and ``other``.</span>
<span class="sd">            * If ``other`` is a GeoSeries, this function tests the &quot;cross&quot; relation between each geometry in the GeoSeries and the geometry with the same index in ``other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Koalas Series</span>
<span class="sd">            Mask of boolean values for each element in the GeoSeries that indicates whether it crosses the geometries in ``other``.</span>

<span class="sd">            * *True*: The first geometry crosses the other.</span>
<span class="sd">            * *False*: The first geometry does not cross the other.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON((0 0,1 0,1 1,0 1,0 0))&quot;, &quot;POLYGON((8 0,9 0,9 1,8 1,8 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;, &quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.crosses(s1)</span>
<span class="sd">        0    False</span>
<span class="sd">        1    False</span>
<span class="sd">        Name: 0, dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_op</span><span class="p">(</span><span class="s2">&quot;st_crosses&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">_validate_arg</span><span class="p">(</span><span class="n">other</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.touches"><a class="viewcode-back" href="../../api_reference/cluster_api/api/arctern_spark.GeoSeries.touches.html#arctern_spark.GeoSeries.touches">[docs]</a>    <span class="k">def</span> <span class="nf">touches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry in the GeoSeries and the corresponding geometry given in ``other``, tests whether the first geometry touches the other.</span>

<span class="sd">        &quot;Touch&quot; means two geometries have common points, and the common points locate only on their boundaries.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geometry or GeoSeries</span>
<span class="sd">            The geometry or GeoSeries to test whether it touches the geometries in the first GeoSeries.</span>

<span class="sd">            * If ``other`` is a geometry, this function tests the &quot;touch&quot; relation between each geometry in the GeoSeries and ``other``.</span>
<span class="sd">            * If ``other`` is a GeoSeries, this function tests the &quot;touch&quot; relation between each geometry in the GeoSeries and the geometry with the same index in ``other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Koalas Series</span>
<span class="sd">            Mask of boolean values for each element in the GeoSeries that indicates whether it touches the geometries in ``other``.</span>

<span class="sd">            * *True*: The first geometry touches the other.</span>
<span class="sd">            * *False*: The first geometry does not touch the other.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON((0 0,1 0,1 1,0 1,0 0))&quot;, &quot;POLYGON((8 0,9 0,9 1,8 1,8 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;, &quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.touches(s1)</span>
<span class="sd">        0    False</span>
<span class="sd">        1     True</span>
<span class="sd">        Name: 0, dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_op</span><span class="p">(</span><span class="s2">&quot;st_touches&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">_validate_arg</span><span class="p">(</span><span class="n">other</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.overlaps"><a class="viewcode-back" href="../../api_reference/cluster_api/api/arctern_spark.GeoSeries.overlaps.html#arctern_spark.GeoSeries.overlaps">[docs]</a>    <span class="k">def</span> <span class="nf">overlaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry in the GeoSeries and the corresponding geometry given in ``other``, tests whether the first geometry &quot;spatially overlaps&quot; the other.</span>

<span class="sd">        &quot;Spatially overlap&quot; here means two geometries intersect but one does not completely contain another.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geometry or GeoSeries</span>
<span class="sd">            The geometry or GeoSeries to test whether it overlaps the geometries in the first GeoSeries.</span>

<span class="sd">            * If ``other`` is a geometry, this function tests the &quot;overlap&quot; relation between each geometry in the GeoSeries and ``other``.</span>
<span class="sd">            * If ``other`` is a GeoSeries, this function tests the &quot;overlap&quot; relation between each geometry in the GeoSeries and the geometry with the same index in ``other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Koalas Series</span>
<span class="sd">            Mask of boolean values for each element in the GeoSeries that indicates whether it overlaps the geometries in ``other``.</span>

<span class="sd">            * *True*: The first geometry overlaps the other.</span>
<span class="sd">            * *False*: The first geometry does not overlap the other.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON((0 0,1 0,1 1,0 1,0 0))&quot;, &quot;POLYGON((8 0,9 0,9 1,8 1,8 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;, &quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.overlaps(s1)</span>
<span class="sd">        0    False</span>
<span class="sd">        1    False</span>
<span class="sd">        Name: 0, dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_op</span><span class="p">(</span><span class="s2">&quot;st_overlaps&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">_validate_arg</span><span class="p">(</span><span class="n">other</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.distance"><a class="viewcode-back" href="../../api_reference/cluster_api/api/arctern_spark.GeoSeries.distance.html#arctern_spark.GeoSeries.distance">[docs]</a>    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry in the GeoSeries and the corresponding geometry given in ``other``, calculates the minimum 2D Cartesian (planar) distance between them.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geometry or GeoSeries</span>
<span class="sd">            The geometry or GeoSeries to calculate the distance between it and the geometries in the first GeoSeries.</span>

<span class="sd">            * If ``other`` is a geometry, this function calculates the distance between each geometry in the GeoSeries and ``other``.</span>
<span class="sd">            * If ``other`` is a GeoSeries, this function calculates the distance between each geometry in the GeoSeries and the geometry with the same index in ``other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Koalas Series</span>
<span class="sd">            Distance between each geometry in the GeoSeries and the corresponding geometry given in ``other``.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; p11 = &quot;LINESTRING(9 0,9 2)&quot;</span>
<span class="sd">        &gt;&gt;&gt; p12 = &quot;POINT(10 2)&quot;</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([p11, p12])</span>
<span class="sd">        &gt;&gt;&gt; p21 = &quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;</span>
<span class="sd">        &gt;&gt;&gt; p22 = &quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([p21, p22])</span>
<span class="sd">        &gt;&gt;&gt; s2.distance(s1)</span>
<span class="sd">        0    1.0</span>
<span class="sd">        1    2.0</span>
<span class="sd">        Name: 0, dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_op</span><span class="p">(</span><span class="s2">&quot;st_distance&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">_validate_arg</span><span class="p">(</span><span class="n">other</span><span class="p">))</span></div>

<div class="viewcode-block" id="GeoSeries.distance_sphere"><a class="viewcode-back" href="../../api_reference/cluster_api/api/arctern_spark.GeoSeries.distance_sphere.html#arctern_spark.GeoSeries.distance_sphere">[docs]</a>    <span class="k">def</span> <span class="nf">distance_sphere</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each point in the GeoSeries and the corresponding point given in ``other``, calculates the minimum spherical distance between them.</span>

<span class="sd">        This function uses a spherical earth and radius derived from the spheroid defined by the SRID.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geometry or GeoSeries</span>
<span class="sd">            The geometry or GeoSeries to calculate the spherical distance between it and the geometries in the first GeoSeries.</span>

<span class="sd">            * If ``other`` is a geometry, this function calculates the spherical distance between each geometry in the GeoSeries and ``other``. The ``crs`` of ``other`` is &quot;EPSG:4326&quot; bu default.</span>
<span class="sd">            * If ``other`` is a GeoSeries, this function calculates the spherical distance between each geometry in the GeoSeries and the geometry with the same index in ``other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Koalas Series</span>
<span class="sd">            Spherical distance between each geometry in the GeoSeries and the corresponding geometry given in ``other``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -------</span>
<span class="sd">        Only the longitude and latitude coordinate reference system (&quot;EPSG:4326&quot;) can be used to calculate spherical distance.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POINT(10 2)&quot;], crs=&quot;EPSG:4326&quot;)</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POINT(10 3)&quot;], crs=&quot;EPSG:4326&quot;)</span>
<span class="sd">        &gt;&gt;&gt; s2.distance_sphere(s1)</span>
<span class="sd">        0    111226.3</span>
<span class="sd">        Name: 0, dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_op</span><span class="p">(</span><span class="s2">&quot;st_distancesphere&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">_validate_arg</span><span class="p">(</span><span class="n">other</span><span class="p">))</span></div>

<div class="viewcode-block" id="GeoSeries.hausdorff_distance"><a class="viewcode-back" href="../../api_reference/cluster_api/api/arctern_spark.GeoSeries.hausdorff_distance.html#arctern_spark.GeoSeries.hausdorff_distance">[docs]</a>    <span class="k">def</span> <span class="nf">hausdorff_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each point in the GeoSeries and the corresponding point given in ``other``, calculates the Hausdorff distance between them.</span>

<span class="sd">        Hausdorff distance is a measure of how similar two geometries are.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geometry or GeoSeries</span>
<span class="sd">            The geometry or GeoSeries to calculate the Hausdorff distance between it and the geometries in the first GeoSeries.</span>

<span class="sd">            * If ``other`` is a geometry, this function calculates the Hausdorff distance between each geometry in the GeoSeries and ``other``.</span>
<span class="sd">            * If ``other`` is a GeoSeries, this function calculates the Hausdorff distance between each geometry in the GeoSeries and the geometry with the same index in ``other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Koalas Series</span>
<span class="sd">            Hausdorff distance between each geometry in the GeoSeries and the corresponding geometry given in ``other``.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON((0 0 ,0 1, 1 1, 1 0, 0 0))&quot;, &quot;POINT(0 0)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON((0 0 ,0 2, 1 1, 1 0, 0 0))&quot;, &quot;POINT(0 1)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.hausdorff_distance(s1)</span>
<span class="sd">        0    1.0</span>
<span class="sd">        1    1.0</span>
<span class="sd">        Name: 0, dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_op</span><span class="p">(</span><span class="s2">&quot;st_hausdorffdistance&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">_validate_arg</span><span class="p">(</span><span class="n">other</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">disjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry in the GeoSeries and the corresponding geometry given in ``other``, tests whether they do not intersect each other.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geometry or GeoSeries</span>
<span class="sd">            The geometry or GeoSeries to test whether it is not intersected with the geometries in the first GeoSeries.</span>
<span class="sd">            * If ``other`` is a geometry, this function tests the intersection relation between each geometry in the GeoSeries and ``other``.</span>
<span class="sd">            * If ``other`` is a GeoSeries, this function tests the intersection relation between each geometry in the GeoSeries and the geometry with the same index in ``other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Koalas Series</span>
<span class="sd">            Mask of boolean values for each element in the GeoSeries that indicates whether it intersects the geometries in ``other``.</span>
<span class="sd">            * *True*: The two geometries do not intersect each other.</span>
<span class="sd">            * *False*: The two geometries intersect each other.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON((0 0,1 0,1 1,0 1,0 0))&quot;, &quot;POLYGON((8 0,9 0,9 1,8 1,8 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;, &quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.disjoint(s1)</span>
<span class="sd">        0    False</span>
<span class="sd">        1     True</span>
<span class="sd">        Name: 0, dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_op</span><span class="p">(</span><span class="s2">&quot;st_disjoint&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">_validate_arg</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># Geometry related binary methods, which return GeoSeries</span>
    <span class="c1"># -------------------------------------------------------------------------</span>

<div class="viewcode-block" id="GeoSeries.intersection"><a class="viewcode-back" href="../../api_reference/cluster_api/api/arctern_spark.GeoSeries.intersection.html#arctern_spark.GeoSeries.intersection">[docs]</a>    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each point in the GeoSeries and the corresponding point given in ``other``, calculates the intersection of them.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geometry or GeoSeries</span>
<span class="sd">            The geometry or GeoSeries to calculate the intersection of it and the geometries in the first GeoSeries.</span>

<span class="sd">            * If ``other`` is a geometry, this function calculates the intersection of each geometry in the GeoSeries and ``other``.</span>
<span class="sd">            * If ``other`` is a GeoSeries, this function calculates the intersection of each geometry in the GeoSeries and the geometry with the same index in ``other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Intersection of each geometry in the GeoSeries and the corresponding geometry given in ``other``.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON ((1 1,1 2,2 2,2 1,1 1))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON ((2 1,3 1,3 2,2 2,2 1))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.intersection(s1)</span>
<span class="sd">        0    LINESTRING (2 2, 2 1)</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_geo</span><span class="p">(</span><span class="s2">&quot;st_intersection&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">_validate_arg</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="n">crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry in the GeoSeries and the corresponding geometry given in ``other``, returns a geometry representing the part of the first geometry that does not intersect with the other.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geometry or GeoSeries</span>
<span class="sd">            The geometry or GeoSeries to calculate the difference from the first GeoSeries.</span>
<span class="sd">            * If ``other`` is a geometry, this function calculates the difference between each geometry in the GeoSeries and ``other``.</span>
<span class="sd">            * If ``other`` is a GeoSeries, this function calculates the difference between each geometry in the GeoSeries and the geometry with the same index in ``other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            A GeoSeries that contains geometries representing the difference between each geometry in the GeoSeries and the corresponding geometry given in ``other``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;LINESTRING (0 0,5 0)&quot;, &quot;MULTIPOINT ((4 0),(6 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;LINESTRING (4 0,6 0)&quot;, &quot;POINT (4 0)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s1.difference(s2)</span>
<span class="sd">        0    LINESTRING (0 0, 4 0)</span>
<span class="sd">        1              POINT (6 0)</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_geo</span><span class="p">(</span><span class="s2">&quot;st_difference&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">_validate_arg</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">symmetric_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a geometry that represents the portions of self and other that do not intersect.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : geometry or GeoSeries</span>
<span class="sd">            The geometry or GeoSeries to calculate the the portions of self and other that do not intersect.</span>
<span class="sd">            * If ``other`` is a geometry, this function calculates the sym difference of each geometry in the GeoSeries and ``other``.</span>
<span class="sd">            * If ``other`` is a GeoSeries, this function calculates the sym difference of each geometry in the GeoSeries and the geometry with the same index in ``other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            A GeoSeries that contains geometries that represents the portions of self and other that do not intersect.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;LINESTRING (0 0,5 0)&quot;, &quot;MULTIPOINT ((4 0),(6 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;LINESTRING (4 0,6 0)&quot;, &quot;POINT (4 0)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s1.symmetric_difference(s2)</span>
<span class="sd">        0    MULTILINESTRING ((0 0, 4 0), (5 0, 6 0))</span>
<span class="sd">        1                                 POINT (6 0)</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_geo</span><span class="p">(</span><span class="s2">&quot;st_symdifference&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">_validate_arg</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns a geometry being a union of two input geometries</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : GeoSeries</span>
<span class="sd">            The GeoSeries to calculate the union of it and the geometries in the first GeoSeries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            A GeoSeries that is the union of each geometry in the GeoSeries and the corresponding geometry given in ``other``.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON((0 0 ,0 1, 1 1, 1 0, 0 0))&quot;, &quot;POINT(0 0)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON((0 0 ,0 2, 1 1, 1 0, 0 0))&quot;, &quot;POINT(0 1)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.union(s1)</span>
<span class="sd">        0    POLYGON ((0 0, 0 1, 0 2, 1 1, 1 0, 0 0))</span>
<span class="sd">        1                   MULTIPOINT ((0 0), (0 1))</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_geo</span><span class="p">(</span><span class="s2">&quot;st_union&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">_validate_arg</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># Geometry related quaternary methods, which return GeoSeries</span>
    <span class="c1"># -------------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rotation_angle</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_radians</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a rotated geometry on a 2D plane.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rotation_angle : float</span>
<span class="sd">            The angle of rotation which can be specified in either degrees (default) or radians by setting use_radians=True. Positive angles are counter-clockwise and negative are clockwise rotations.</span>
<span class="sd">        origin : string or tuple</span>
<span class="sd">            The point of origin can be a keyword ‘center’ for 2D bounding box center (default), ‘centroid’ for the geometry’s 2D centroid, or a coordinate tuple (x, y).</span>
<span class="sd">        use_radians : boolean</span>
<span class="sd">            Whether to interpret the angle of rotation as degrees or radians.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            A GeoSeries with rotated geometries.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;LINESTRING (0 0,5 0)&quot;, &quot;MULTIPOINT ((4 0),(6 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; import math</span>
<span class="sd">        &gt;&gt;&gt; s1.rotate(90, (0,1)).precision_reduce(3)</span>
<span class="sd">        0        LINESTRING (1 1, 1 6)</span>
<span class="sd">        1    MULTIPOINT ((1 5), (1 7))</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">math</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">use_radians</span><span class="p">:</span>
            <span class="n">rotation_angle</span> <span class="o">=</span> <span class="n">rotation_angle</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span>

        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">_column_geo</span><span class="p">(</span><span class="s2">&quot;st_rotate&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">rotation_angle</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">_column_geo</span><span class="p">(</span><span class="s2">&quot;st_rotate&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">rotation_angle</span><span class="p">),</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">origin</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">origin_x</span> <span class="o">=</span> <span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">origin_y</span> <span class="o">=</span> <span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">_column_geo</span><span class="p">(</span><span class="s2">&quot;st_rotate&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">rotation_angle</span><span class="p">),</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">origin_x</span><span class="p">),</span> <span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">origin_y</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># utils</span>
    <span class="c1"># -------------------------------------------------------------------------</span>

<div class="viewcode-block" id="GeoSeries.polygon_from_envelope"><a class="viewcode-back" href="../../api_reference/cluster_api/api/arctern_spark.GeoSeries.polygon_from_envelope.html#arctern_spark.GeoSeries.polygon_from_envelope">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">polygon_from_envelope</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">min_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs rectangular POLYGON objects within the given spatial range. The edges of the rectangles are parallel to the coordinate axises.</span>

<span class="sd">        ``min_x``, ``min_y``, ``max_x``, and ``max_y`` are Series so that polygons can be created in batch. The number of values in the four Series should be the same.</span>

<span class="sd">        Suppose that the demension of ``min_x`` is *N*, the returned GeoSeries of this function should contains *N* rectangles. The shape and position of the rectangle with index *i* is defined by its bottom left vertex *(min_x[i], min_y[i])* and top right vertex *(max_x[i], max_y[i])*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        min_x : Series</span>
<span class="sd">            The minimum x coordinates of the rectangles.</span>
<span class="sd">        min_y : Series</span>
<span class="sd">            The minimum y coordinates of the rectangles.</span>
<span class="sd">        max_x : Series</span>
<span class="sd">            The maximum x coordinates of the rectangles.</span>
<span class="sd">        max_y : Series</span>
<span class="sd">            The maximum y coordinates of the rectangles.</span>
<span class="sd">        crs : str, optional</span>
<span class="sd">            A string representation of Coordinate Reference System (CRS).</span>
<span class="sd">            The string is made up of an authority code and a SRID (Spatial Reference Identifier), for example, &quot;EPSG:4326&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Sequence of rectangular POLYGON objects within the given spatial range.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from pandas import Series</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; min_x = Series([0.0, 1.0])</span>
<span class="sd">        &gt;&gt;&gt; max_x = Series([2.0, 1.5])</span>
<span class="sd">        &gt;&gt;&gt; min_y = Series([0.0, 1.0])</span>
<span class="sd">        &gt;&gt;&gt; max_y = Series([1.0, 1.5])</span>
<span class="sd">        &gt;&gt;&gt; GeoSeries.polygon_from_envelope(min_x, min_y, max_x, max_y)</span>
<span class="sd">        0            POLYGON ((0 0, 0 1, 2 1, 2 0, 0 0))</span>
<span class="sd">        1    POLYGON ((1 1, 1 1.5, 1.5 1.5, 1.5 1, 1 1))</span>
<span class="sd">        Name: min_x, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">min_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span> <span class="o">=</span> <span class="n">_validate_args</span><span class="p">(</span>
            <span class="n">min_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">_kdf</span> <span class="o">=</span> <span class="n">ks</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">min_x</span><span class="p">)</span>
        <span class="n">ks</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s1">&#39;compute.ops_on_diff_frames&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">kdf</span> <span class="o">=</span> <span class="n">_kdf</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">_kdf</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="s2">&quot;min_x&quot;</span><span class="p">})</span>
        <span class="n">kdf</span><span class="p">[</span><span class="s2">&quot;min_y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_y</span>
        <span class="n">kdf</span><span class="p">[</span><span class="s2">&quot;max_x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_x</span>
        <span class="n">kdf</span><span class="p">[</span><span class="s2">&quot;max_y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_y</span>
        <span class="k">return</span> <span class="n">_column_geo</span><span class="p">(</span><span class="s2">&quot;st_polygonfromenvelope&quot;</span><span class="p">,</span> <span class="n">kdf</span><span class="p">[</span><span class="s2">&quot;min_x&quot;</span><span class="p">],</span> <span class="n">kdf</span><span class="p">[</span><span class="s2">&quot;min_y&quot;</span><span class="p">],</span> <span class="n">kdf</span><span class="p">[</span><span class="s2">&quot;max_x&quot;</span><span class="p">],</span> <span class="n">kdf</span><span class="p">[</span><span class="s2">&quot;max_y&quot;</span><span class="p">],</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.point"><a class="viewcode-back" href="../../api_reference/cluster_api/api/arctern_spark.GeoSeries.point.html#arctern_spark.GeoSeries.point">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">point</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs POINT objects based on the given coordinates.</span>

<span class="sd">        ``x`` and ``y`` are Series so that points can be created in batch. The number of values in the two Series should be the same.</span>

<span class="sd">        Suppose that the demension of ``x`` is *N*, the returned GeoSeries of this function should contains *N* points. The position of the *i*th point is defined by its coordinates *(x[i], y[i]).*</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : Series</span>
<span class="sd">            X coordinates of points.</span>
<span class="sd">        y : Series</span>
<span class="sd">            Y coordinates of points.</span>
<span class="sd">        crs : str, optional</span>
<span class="sd">            A string representation of Coordinate Reference System (CRS).</span>
<span class="sd">            The string is made up of an authority code and a SRID (Spatial Reference Identifier), for example, &quot;EPSG:4326&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Sequence of POINT objects.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from pandas import Series</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; x = Series([1.3, 2.5])</span>
<span class="sd">        &gt;&gt;&gt; y = Series([1.3, 2.5])</span>
<span class="sd">        &gt;&gt;&gt; GeoSeries.point(x, y)</span>
<span class="sd">        0    POINT (1.3 1.3)</span>
<span class="sd">        1    POINT (2.5 2.5)</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_column_geo</span><span class="p">(</span><span class="s2">&quot;st_point&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">_validate_args</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.geom_from_geojson"><a class="viewcode-back" href="../../api_reference/cluster_api/api/arctern_spark.GeoSeries.geom_from_geojson.html#arctern_spark.GeoSeries.geom_from_geojson">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">geom_from_geojson</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">json</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs geometries from GeoJSON strings.</span>

<span class="sd">        ``json`` is Series so that geometries can be created in batch.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        json : Series</span>
<span class="sd">            String representations of geometries in JSON format.</span>
<span class="sd">        crs : str, optional</span>
<span class="sd">            A string representation of Coordinate Reference System (CRS).</span>
<span class="sd">            The string is made up of an authority code and a SRID (Spatial Reference Identifier), for example, &quot;EPSG:4326&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Sequence of geometries.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from pandas import Series</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; json = Series([&#39;{&quot;type&quot;:&quot;LineString&quot;,&quot;coordinates&quot;:[[1,2],[4,5],[7,8]]}&#39;])</span>
<span class="sd">        &gt;&gt;&gt; GeoSeries.geom_from_geojson(json)</span>
<span class="sd">        0    LINESTRING (1 2, 4 5, 7 8)</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">json</span><span class="p">,</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">ks</span><span class="o">.</span><span class="n">Series</span><span class="p">))</span> <span class="ow">and</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">json</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">json</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">GeoSeries</span><span class="p">([],</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_column_geo</span><span class="p">(</span><span class="s2">&quot;st_geomfromgeojson&quot;</span><span class="p">,</span> <span class="n">_validate_arg</span><span class="p">(</span><span class="n">json</span><span class="p">),</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.as_geojson"><a class="viewcode-back" href="../../api_reference/cluster_api/api/arctern_spark.GeoSeries.as_geojson.html#arctern_spark.GeoSeries.as_geojson">[docs]</a>    <span class="k">def</span> <span class="nf">as_geojson</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transforms all geometries in the GeoSeries to GeoJSON strings.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Koalas Series</span>
<span class="sd">            Sequence of geometries in GeoJSON format.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.as_geojson()</span>
<span class="sd">        0    {&quot;type&quot;:&quot;Point&quot;,&quot;coordinates&quot;:[1.0,1.0]}</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_op</span><span class="p">(</span><span class="s2">&quot;st_asgeojson&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.to_wkt"><a class="viewcode-back" href="../../api_reference/cluster_api/api/arctern_spark.GeoSeries.to_wkt.html#arctern_spark.GeoSeries.to_wkt">[docs]</a>    <span class="k">def</span> <span class="nf">to_wkt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transforms all geometries in the GeoSeries to `WKT &lt;https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry&gt;`_ strings.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Koalas Series</span>
<span class="sd">            Sequence of geometries in WKT format.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.to_wkt()</span>
<span class="sd">        0    POINT (1 1)</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_op</span><span class="p">(</span><span class="s2">&quot;st_astext&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.to_wkb"><a class="viewcode-back" href="../../api_reference/cluster_api/api/arctern_spark.GeoSeries.to_wkb.html#arctern_spark.GeoSeries.to_wkb">[docs]</a>    <span class="k">def</span> <span class="nf">to_wkb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transforms all geometries in the GeoSeries to `WKB &lt;https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry#Well-known_binary&gt;`_ strings.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Koalas Series</span>
<span class="sd">            Sequence of geometries in WKB format.</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">        &gt;&gt;&gt; pd.set_option(&quot;max_colwidth&quot;, 1000)</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.to_wkb()</span>
<span class="sd">        0    [0, 0, 0, 0, 1, 63, 240, 0, 0, 0, 0, 0, 0, 63, 240, 0, 0, 0, 0, 0, 0]</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_column_op</span><span class="p">(</span><span class="s2">&quot;st_aswkb&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">head</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the first n rows.</span>

<span class="sd">        This function returns the first n rows for the object based on position.</span>
<span class="sd">        It is useful for quickly testing if your object has the right type of data in it.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : Integer, default =  5</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            The first n rows of the GeoSeries.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POLYGON((0 0, 0 1, 1 1, 1 0, 0 0))&quot;, &quot;LINESTRING (0 0, 1 1, 1 7)&quot;, &quot;POINT(4 4)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.head(2)</span>
<span class="sd">        0    POLYGON ((0 0, 0 1, 1 1, 1 0, 0 0))</span>
<span class="sd">        1             LINESTRING (0 0, 1 1, 1 7)</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">r</span><span class="o">.</span><span class="n">set_crs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span>

    <span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the elements in the given *positional* indices along an axis.</span>

<span class="sd">        This means that we are not indexing according to actual values in</span>
<span class="sd">        the index attribute of the object. We are indexing according to the</span>
<span class="sd">        actual position of the element in the object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices : array-like</span>
<span class="sd">            An array of ints indicating which positions to take.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            An array-like containing the elements taken from the GeoSeries.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POLYGON((0 0, 0 1, 1 1, 1 0, 0 0))&quot;, &quot;LINESTRING (0 0, 1 1, 1 7)&quot;, &quot;POINT(4 4)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.take([0,2])</span>
<span class="sd">        0    POLYGON ((0 0, 0 1, 1 1, 1 0, 0 0))</span>
<span class="sd">        2                            POINT (4 4)</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">r</span><span class="o">.</span><span class="n">set_crs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span>

    <span class="k">def</span> <span class="nf">isin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether `values` are contained in GeoSeries.</span>

<span class="sd">        Return a boolean Series showing whether each element in the Series</span>
<span class="sd">        matches an element in the passed sequence of `values` exactly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values : list or set</span>
<span class="sd">            The sequence of values to test.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        isin : Series (bool dtype)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; p1 = [&quot;POINT (1 1)&quot;, &quot;POINT (2 2)&quot;, &quot;POINT (3 3)&quot;]</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT (1 1)&quot;, &quot;POINT (2 2)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.isin(p1)</span>
<span class="sd">        0    True</span>
<span class="sd">        1    True</span>
<span class="sd">        Name: 0, dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;only list-like objects are allowed to be passed&quot;</span>
                <span class="s2">&quot; to isin(), you passed a [</span><span class="si">{values_type}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">values_type</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_with_new_scol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">column</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="n">_validate_arg</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]))</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace values where the condition is False.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cond : boolean Series</span>
<span class="sd">            Where cond is True, keep the original value. Where False,</span>
<span class="sd">            replace with corresponding value from other.</span>
<span class="sd">        other : scalar, Series</span>
<span class="sd">            Entries where cond is False are replaced with corresponding value from other.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; p1 = [&quot;POLYGON ((0 0, 0 1, 1 1, 1 0, 0 0))&quot;, &quot;POINT (2 2)&quot;, &quot;LINESTRING (0 0, 3 3, 7 6)&quot;]</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries(p1)</span>
<span class="sd">        &gt;&gt;&gt; s.where(s.npoints &lt; 4)</span>
<span class="sd">        0                          None</span>
<span class="sd">        1                   POINT (2 2)</span>
<span class="sd">        2    LINESTRING (0 0, 3 3, 7 6)</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">GeoSeries</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">_validate_arg</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cond</span><span class="o">=</span><span class="n">cond</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace values where the condition is True.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cond : boolean Series</span>
<span class="sd">            Where cond is False, keep the original value. Where True,</span>
<span class="sd">            replace with corresponding value from other.</span>
<span class="sd">        other : scalar, Series</span>
<span class="sd">            Entries where cond is True are replaced with corresponding value from other.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; p1 = [&quot;POLYGON ((0 0, 0 1, 1 1, 1 0, 0 0))&quot;, &quot;POINT (2 2)&quot;, &quot;LINESTRING (0 0, 3 3, 7 6)&quot;]</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries(p1)</span>
<span class="sd">        &gt;&gt;&gt; s.mask(s.npoints &lt; 4)</span>
<span class="sd">        0    POLYGON ((0 0, 0 1, 1 1, 1 0, 0 0))</span>
<span class="sd">        1                                   None</span>
<span class="sd">        2                                   None</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">GeoSeries</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">_validate_arg</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="n">cond</span><span class="o">=</span><span class="n">cond</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_replace</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace values given in to_replace with value.</span>
<span class="sd">        Values of the GeoSeries are replaced with other values dynamically.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        to_replace : str, list, dict, Series, int, float, or None</span>
<span class="sd">            How to find the values that will be replaced.</span>
<span class="sd">            * numeric, str:</span>

<span class="sd">                - numeric: numeric values equal to to_replace will be replaced with value</span>
<span class="sd">                - str: string exactly matching to_replace will be replaced with value</span>

<span class="sd">            * list of str or numeric:</span>

<span class="sd">                - if to_replace and value are both lists, they must be the same length.</span>
<span class="sd">                - str and numeric rules apply as above.</span>

<span class="sd">            * dict:</span>

<span class="sd">                - Dicts can be used to specify different replacement values for different</span>
<span class="sd">                  existing values.</span>
<span class="sd">                  For example, {&#39;a&#39;: &#39;b&#39;, &#39;y&#39;: &#39;z&#39;} replaces the value ‘a’ with ‘b’ and ‘y’</span>
<span class="sd">                  with ‘z’. To use a dict in this way the value parameter should be None.</span>
<span class="sd">                - For a DataFrame a dict can specify that different values should be replaced</span>
<span class="sd">                  in different columns. For example, {&#39;a&#39;: 1, &#39;b&#39;: &#39;z&#39;} looks for the value 1</span>
<span class="sd">                  in column ‘a’ and the value ‘z’ in column ‘b’ and replaces these values with</span>
<span class="sd">                  whatever is specified in value.</span>
<span class="sd">                  The value parameter should not be None in this case.</span>
<span class="sd">                  You can treat this as a special case of passing two lists except that you are</span>
<span class="sd">                  specifying the column to search in.</span>

<span class="sd">            See the examples section for examples of each of these.</span>

<span class="sd">        value : scalar, dict, list, str default None</span>
<span class="sd">            Value to replace any values matching to_replace with.</span>
<span class="sd">            For a DataFrame a dict of values can be used to specify which value to use</span>
<span class="sd">            for each column (columns not in the dict will not be filled).</span>
<span class="sd">            Regular expressions, strings and lists or dicts of such objects are also allowed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            Object after replacement.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; p1 = [&quot;POLYGON ((0 0, 0 1, 1 1, 1 0, 0 0))&quot;, &quot;POINT (2 2)&quot;, &quot;LINESTRING (0 0, 3 3, 7 6)&quot;]</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries(p1)</span>
<span class="sd">        &gt;&gt;&gt; s.replace(s[0], s[1])</span>
<span class="sd">        0                   POINT (2 2)</span>
<span class="sd">        1                   POINT (2 2)</span>
<span class="sd">        2    LINESTRING (0 0, 3 3, 7 6)</span>
<span class="sd">        Name: 0, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">to_replace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">to_replace</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytearray</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;to_replace&#39; should be one of str, bytearray, bytes&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">regex</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;replace currently not support for regex&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">to_replace</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_replace</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Replacement lists must match in length. Expecting </span><span class="si">{}</span><span class="s2"> got </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">to_replace</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="n">to_replace</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">to_replace</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>

        <span class="n">current</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">column</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">_validate_arg</span><span class="p">(</span><span class="n">to_replace</span><span class="p">)),</span> <span class="n">_validate_arg</span><span class="p">(</span><span class="n">value</span><span class="p">))</span><span class="o">.</span><span class="n">otherwise</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">column</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_with_new_scol</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">between</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">inclusive</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return boolean Series equivalent to left &lt;= series &lt;= right.</span>
<span class="sd">        This function returns a boolean vector containing `True` wherever the</span>
<span class="sd">        corresponding Series element is between the boundary values `left` and</span>
<span class="sd">        `right`. NA values are treated as `False`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        left : scalar or list-like</span>
<span class="sd">            Left boundary.</span>
<span class="sd">        right : scalar or list-like</span>
<span class="sd">            Right boundary.</span>
<span class="sd">        inclusive : bool, default True</span>
<span class="sd">            Include boundaries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Series representing whether each element is between left and</span>
<span class="sd">            right (inclusive).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function is equivalent to ``(left &lt;= ser) &amp; (ser &lt;= right)``</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from arctern_spark import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; p1 = [&quot;POLYGON ((0 0, 0 1, 1 1, 1 0, 0 0))&quot;, &quot;POINT (2 2)&quot;, &quot;LINESTRING (0 0, 3 3, 7 6)&quot;]</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries(p1)</span>
<span class="sd">        &gt;&gt;&gt; s.between(p1[0], p1[2])</span>
<span class="sd">        0    False</span>
<span class="sd">        1    False</span>
<span class="sd">        2    False</span>
<span class="sd">        Name: 0, dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">between</span><span class="p">(</span><span class="n">_validate_arg</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">_validate_arg</span><span class="p">(</span><span class="n">right</span><span class="p">),</span> <span class="n">inclusive</span><span class="o">=</span><span class="n">inclusive</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_calculate_bbox_from_wkb</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">geom_wkb</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate bounding box for the geom_wkb geometry.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">osgeo</span> <span class="kn">import</span> <span class="n">ogr</span>
        <span class="n">geometry</span> <span class="o">=</span> <span class="n">ogr</span><span class="o">.</span><span class="n">CreateGeometryFromWkb</span><span class="p">(</span><span class="n">geom_wkb</span><span class="p">)</span>
        <span class="n">env</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">GetEnvelope</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">env</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">env</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">env</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">env</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bbox</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate bounding box for the each geometry in the GeoSeries.</span>

<span class="sd">        :rtype: a Pandas Series with each item is a (minx, miny, maxx, maxy) list</span>
<span class="sd">        :return: Bounding box of each geometry.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">envelope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">envelope</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">GeoSeries</span><span class="o">.</span><span class="n">_calculate_bbox_from_wkb</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">envelope</span>

    <span class="k">def</span> <span class="nf">iterfeatures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="s2">&quot;null&quot;</span><span class="p">,</span> <span class="n">show_bbox</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator that yields feature dictionaries that comply with</span>
<span class="sd">        Arctern.GeoSeries.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        na: str {&#39;null&#39;, &#39;drop&#39;, &#39;keep&#39;}, default &#39;null&#39;</span>
<span class="sd">            Indicates how to output missing (NaN) values in the GeoDataFrame</span>
<span class="sd">            * null: ouput the missing entries as JSON null</span>
<span class="sd">            * drop: remove the property from the feature. This applies to</span>
<span class="sd">                    each feature individually so that features may have</span>
<span class="sd">                    different properties</span>
<span class="sd">            * keep: output the missing entries as NaN</span>

<span class="sd">        show_bbox: bool</span>
<span class="sd">            whether to include bbox (bounds box) in the geojson. default False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">json</span>
        <span class="k">if</span> <span class="n">na</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;null&quot;</span><span class="p">,</span> <span class="s2">&quot;drop&quot;</span><span class="p">,</span> <span class="s2">&quot;keep&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown na method </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">na</span><span class="p">))</span>

        <span class="n">ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">fid</span><span class="p">,</span> <span class="n">geom</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()):</span>
            <span class="n">feature</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">fid</span><span class="p">),</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Feature&quot;</span><span class="p">,</span>
                <span class="s2">&quot;properties&quot;</span><span class="p">:</span> <span class="p">{},</span>
                <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">GeoSeries</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span><span class="o">.</span><span class="n">as_geojson</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">geom</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">show_bbox</span><span class="p">:</span>
                <span class="n">feature</span><span class="p">[</span><span class="s2">&quot;bbox&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">GeoSeries</span><span class="o">.</span><span class="n">_calculate_bbox_from_wkb</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span> <span class="k">if</span> <span class="n">geom</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">yield</span> <span class="n">feature</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">item</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read a file or OGR dataset to GeoSeries.</span>

<span class="sd">        Supported file format is listed in</span>
<span class="sd">        https://github.com/Toblerity/Fiona/blob/master/fiona/drvsupport.py.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fp: URI (str or pathlib.Path), or file-like object</span>
<span class="sd">            A dataset resource identifier or file object.</span>

<span class="sd">        bbox: a (minx, miny, maxx, maxy) tuple</span>
<span class="sd">            Filter for geometries which spatial intersects with by the provided bounding box.</span>

<span class="sd">        mask: a GeoSeries(should have same crs), wkb formed bytes or wkt formed string</span>
<span class="sd">            Filter for geometries which spatial intersects with by the provided geometry.</span>

<span class="sd">        item: int or slice</span>
<span class="sd">            Load special items by skipping over items or stopping at a specific item.</span>

<span class="sd">        **kwargs:</span>
<span class="sd">            Keyword arguments to ``fiona.open()``. e.g. ``layer``, ``enabled_drivers``. see https://fiona.readthedocs.io/en/latest/fiona.html#fiona.open for more info.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">            A GeoSeries read from file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">fiona</span>
        <span class="kn">import</span> <span class="nn">json</span>
        <span class="k">with</span> <span class="n">fiona</span><span class="o">.</span><span class="n">Env</span><span class="p">():</span>
            <span class="k">with</span> <span class="n">fiona</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">as</span> <span class="n">features</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">features</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">crs</span> <span class="o">=</span> <span class="n">features</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;init&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">crs</span> <span class="o">=</span> <span class="n">features</span><span class="o">.</span><span class="n">crs_wkt</span>

                <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)):</span>
                        <span class="n">mask</span> <span class="o">=</span> <span class="n">GeoSeries</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">GeoSeries</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unsupported mask type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">unary_union</span><span class="p">()</span><span class="o">.</span><span class="n">as_geojson</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))):</span>
                    <span class="n">item</span> <span class="o">=</span> <span class="p">(</span><span class="n">item</span><span class="p">,)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                    <span class="n">item</span> <span class="o">=</span> <span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unsupported item type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">features</span> <span class="o">=</span> <span class="n">features</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="n">bbox</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

                <span class="n">geoms</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">features</span><span class="p">:</span>
                    <span class="n">geometry</span> <span class="o">=</span> <span class="n">feature</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span>
                    <span class="n">geoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">geometry</span><span class="p">)</span> <span class="k">if</span> <span class="n">geometry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;{&quot;type&quot;: &quot;null&quot;}&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">GeoSeries</span><span class="o">.</span><span class="n">geom_from_geojson</span><span class="p">(</span><span class="n">geoms</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="s2">&quot;ESRI Shapefile&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Store GeoSeries to a file or OGR dataset.</span>

<span class="sd">        :type fp: URI (str or pathlib.Path), or file-like object</span>
<span class="sd">        :param fp: A dataset resource identifier or file object.</span>

<span class="sd">        :type mode: str, default &quot;w&quot;</span>
<span class="sd">        :param mode: &#39;a&#39; to append, or &#39;w&#39; to write. Not all driver support</span>
<span class="sd">                      append, see &quot;Supported driver list&quot; below for more info.</span>

<span class="sd">        :type driver: str, default &quot;ESRI Shapefile&quot;</span>
<span class="sd">        :param driver: The OGR format driver. It&#39;s  represents a</span>
<span class="sd">                       translator for a specific format. Supported driver is listed in</span>
<span class="sd">                       https://github.com/Toblerity/Fiona/blob/master/fiona/drvsupport.py.</span>

<span class="sd">        :param kwargs: Keyword arguments to `fiona.open()`. e.g. `layer` used to</span>
<span class="sd">                       write data to multi-layer dataset.</span>
<span class="sd">                       see https://fiona.readthedocs.io/en/latest/fiona.html#fiona.open for</span>
<span class="sd">                       more info.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">geo_types</span> <span class="o">=</span> <span class="s2">&quot;Unknown&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geom_type</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">geo_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geom_type</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">())</span>

        <span class="n">schema</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;properties&quot;</span><span class="p">:</span> <span class="p">{},</span> <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">geo_types</span><span class="p">}</span>
        <span class="c1"># TODO: fiona expected crs like Proj4 style mappings, &quot;EPSG:4326&quot; or WKT representations</span>
        <span class="n">crs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span>
        <span class="kn">import</span> <span class="nn">fiona</span>
        <span class="k">with</span> <span class="n">fiona</span><span class="o">.</span><span class="n">Env</span><span class="p">():</span>
            <span class="k">with</span> <span class="n">fiona</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">driver</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">as</span> <span class="n">sink</span><span class="p">:</span>
                <span class="n">sink</span><span class="o">.</span><span class="n">writerecords</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iterfeatures</span><span class="p">())</span></div>


<span class="k">def</span> <span class="nf">first_series</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a DataFrame and returns the first column of the DataFrame as a Series</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="p">(</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)),</span> <span class="nb">type</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
        <span class="n">kss</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">_kser_for</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">column_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="kn">from</span> <span class="nn">arctern_spark.scala_wrapper</span> <span class="kn">import</span> <span class="n">GeometryUDT</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kss</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">data_type</span><span class="p">,</span> <span class="n">GeometryUDT</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">GeoSeries</span><span class="p">(</span><span class="n">kss</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">kss</span>
    <span class="k">return</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>


<span class="n">ks</span><span class="o">.</span><span class="n">series</span><span class="o">.</span><span class="n">first_series</span> <span class="o">=</span> <span class="n">first_series</span>
<span class="c1"># Series._with_new_col has a bug in koalas==1.0.0, monkey patch this for Series</span>
<span class="c1"># see GH1633 https://github.com/databricks/koalas/issues/1633</span>
<span class="n">ks</span><span class="o">.</span><span class="n">Series</span><span class="o">.</span><span class="n">_with_new_scol</span> <span class="o">=</span> <span class="n">GeoSeries</span><span class="o">.</span><span class="n">_with_new_scol</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, zilliz
      <span class="lastupdated">
        Last updated on Aug 04, 2020.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>